/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package mothershipattendance;

import java.awt.Component;
import java.util.ArrayList;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JTable;
import javax.swing.SwingWorker;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;

/**
 *
 * @author tylerfontana
 */
public class ManageStudentsPanel extends javax.swing.JPanel {

    /**
     * Creates new form CreateNewClassJPanel
     */
    public ManageStudentsPanel() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel9 = new javax.swing.JPanel();
        jPanel10 = new javax.swing.JPanel();
        jLabel6 = new javax.swing.JLabel();
        jPanel11 = new javax.swing.JPanel();
        jComboBox2 = new javax.swing.JComboBox<>();
        jButton5 = new javax.swing.JButton();
        jPanel14 = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        jPanel6 = new javax.swing.JPanel();
        jPanel7 = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jPanel8 = new javax.swing.JPanel();
        jComboBox1 = new javax.swing.JComboBox<>();
        jLabel4 = new javax.swing.JLabel();
        jPanel13 = new javax.swing.JPanel();
        jButton6 = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        classListTableScrollPane = new javax.swing.JScrollPane();
        classListTable = new javax.swing.JTable();
        jPanel17 = new javax.swing.JPanel();
        jPanel18 = new javax.swing.JPanel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jPanel12 = new javax.swing.JPanel();
        allStudentsTableScrollPane = new javax.swing.JScrollPane();
        allStudentsTable = new javax.swing.JTable();
        jPanel3 = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();
        jPanel15 = new javax.swing.JPanel();
        jButton2 = new javax.swing.JButton();
        jButton7 = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jPanel4 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jPanel5 = new javax.swing.JPanel();
        jPanel16 = new javax.swing.JPanel();

        setMaximumSize(new java.awt.Dimension(829, 360));
        setMinimumSize(new java.awt.Dimension(829, 360));
        setOpaque(false);
        setPreferredSize(new java.awt.Dimension(829, 360));
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                formComponentShown(evt);
            }
        });
        setLayout(new javax.swing.OverlayLayout(this));

        jPanel9.setOpaque(false);

        jPanel10.setOpaque(false);

        jLabel6.setFont(new java.awt.Font("Lucida Grande", 1, 14)); // NOI18N
        jLabel6.setForeground(new java.awt.Color(255, 255, 255));
        jLabel6.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel6.setText("Choose An Option Below:");

        javax.swing.GroupLayout jPanel10Layout = new javax.swing.GroupLayout(jPanel10);
        jPanel10.setLayout(jPanel10Layout);
        jPanel10Layout.setHorizontalGroup(
            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 542, Short.MAX_VALUE)
            .addGroup(jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel10Layout.createSequentialGroup()
                    .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 530, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap()))
        );
        jPanel10Layout.setVerticalGroup(
            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 46, Short.MAX_VALUE)
            .addGroup(jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel10Layout.createSequentialGroup()
                    .addGap(7, 7, 7)
                    .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(8, Short.MAX_VALUE)))
        );

        jPanel11.setOpaque(false);

        jComboBox2.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { " ---------------------------------- ", " Show Class Student List", " Show List of All Availiable Students" }));
        jComboBox2.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jComboBox2FocusGained(evt);
            }
        });

        jButton5.setText("Go");
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel11Layout = new javax.swing.GroupLayout(jPanel11);
        jPanel11.setLayout(jPanel11Layout);
        jPanel11Layout.setHorizontalGroup(
            jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel11Layout.createSequentialGroup()
                .addContainerGap(42, Short.MAX_VALUE)
                .addComponent(jComboBox2, javax.swing.GroupLayout.PREFERRED_SIZE, 284, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(40, 40, 40)
                .addComponent(jButton5, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(21, 21, 21))
        );
        jPanel11Layout.setVerticalGroup(
            jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel11Layout.createSequentialGroup()
                .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jComboBox2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton5))
                .addGap(0, 13, Short.MAX_VALUE))
        );

        jComboBox1.addPopupMenuListener(new BoundsPopupMenuListener());

        jPanel14.setOpaque(false);

        jLabel7.setFont(new java.awt.Font("Lucida Grande", 1, 14)); // NOI18N
        jLabel7.setForeground(new java.awt.Color(255, 255, 255));
        jLabel7.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel7.setIcon(new javax.swing.ImageIcon(getClass().getResource("/mothershipattendance/Image/returnButton25x25.png"))); // NOI18N
        jLabel7.setToolTipText("<html><center>Click This Button to Return<br></br>to the Class Search Selection Screen.</center></html>");
        jLabel7.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel7MouseClicked(evt);
            }
        });

        javax.swing.GroupLayout jPanel14Layout = new javax.swing.GroupLayout(jPanel14);
        jPanel14.setLayout(jPanel14Layout);
        jPanel14Layout.setHorizontalGroup(
            jPanel14Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
            .addGroup(jPanel14Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel14Layout.createSequentialGroup()
                    .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(142, 142, 142)))
        );
        jPanel14Layout.setVerticalGroup(
            jPanel14Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 80, Short.MAX_VALUE)
            .addGroup(jPanel14Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel14Layout.createSequentialGroup()
                    .addContainerGap()
                    .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(41, Short.MAX_VALUE)))
        );

        javax.swing.GroupLayout jPanel9Layout = new javax.swing.GroupLayout(jPanel9);
        jPanel9.setLayout(jPanel9Layout);
        jPanel9Layout.setHorizontalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel9Layout.createSequentialGroup()
                .addContainerGap(197, Short.MAX_VALUE)
                .addComponent(jPanel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(186, 186, 186))
            .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel9Layout.createSequentialGroup()
                    .addContainerGap(174, Short.MAX_VALUE)
                    .addComponent(jPanel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(113, Short.MAX_VALUE)))
            .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel9Layout.createSequentialGroup()
                    .addContainerGap(519, Short.MAX_VALUE)
                    .addComponent(jPanel14, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(271, 271, 271)))
        );
        jPanel9Layout.setVerticalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel9Layout.createSequentialGroup()
                .addGap(76, 76, 76)
                .addComponent(jPanel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(242, Short.MAX_VALUE))
            .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel9Layout.createSequentialGroup()
                    .addContainerGap(21, Short.MAX_VALUE)
                    .addComponent(jPanel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(293, Short.MAX_VALUE)))
            .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel9Layout.createSequentialGroup()
                    .addGap(69, 69, 69)
                    .addComponent(jPanel14, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(211, Short.MAX_VALUE)))
        );

        add(jPanel9);

        jPanel6.setOpaque(false);

        jPanel7.setOpaque(false);

        jLabel5.setFont(new java.awt.Font("Lucida Grande", 1, 14)); // NOI18N
        jLabel5.setForeground(new java.awt.Color(255, 255, 255));
        jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel5.setText("Begin by Selecting the Class You Want to Manage Student Access For:");

        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addGap(40, 40, 40)
                .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 548, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(82, Short.MAX_VALUE))
        );
        jPanel7Layout.setVerticalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel7Layout.createSequentialGroup()
                .addContainerGap(9, Short.MAX_VALUE)
                .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        jPanel8.setOpaque(false);

        jComboBox1.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jComboBox1FocusGained(evt);
            }
        });

        jLabel4.setIcon(new javax.swing.ImageIcon(getClass().getResource("/mothershipattendance/Image/refreshIcon.png"))); // NOI18N
        jLabel4.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel4MouseClicked(evt);
            }
        });

        javax.swing.GroupLayout jPanel8Layout = new javax.swing.GroupLayout(jPanel8);
        jPanel8.setLayout(jPanel8Layout);
        jPanel8Layout.setHorizontalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel8Layout.createSequentialGroup()
                .addGap(47, 47, 47)
                .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 337, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel4)
                .addContainerGap(54, Short.MAX_VALUE))
        );
        jPanel8Layout.setVerticalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel8Layout.createSequentialGroup()
                .addContainerGap(7, Short.MAX_VALUE)
                .addGroup(jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel4)
                    .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        jComboBox1.addPopupMenuListener(new BoundsPopupMenuListener());

        jPanel13.setOpaque(false);

        jButton6.setText("Go");
        jButton6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton6ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel13Layout = new javax.swing.GroupLayout(jPanel13);
        jPanel13.setLayout(jPanel13Layout);
        jPanel13Layout.setHorizontalGroup(
            jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 85, Short.MAX_VALUE)
            .addGroup(jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel13Layout.createSequentialGroup()
                    .addGap(4, 4, 4)
                    .addComponent(jButton6)
                    .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
        );
        jPanel13Layout.setVerticalGroup(
            jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 42, Short.MAX_VALUE)
            .addGroup(jPanel13Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel13Layout.createSequentialGroup()
                    .addContainerGap()
                    .addComponent(jButton6, javax.swing.GroupLayout.DEFAULT_SIZE, 29, Short.MAX_VALUE)
                    .addGap(7, 7, 7)))
        );

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap(156, Short.MAX_VALUE)
                .addComponent(jPanel8, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(204, 204, 204))
            .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel6Layout.createSequentialGroup()
                    .addContainerGap(109, Short.MAX_VALUE)
                    .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(50, Short.MAX_VALUE)))
            .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel6Layout.createSequentialGroup()
                    .addContainerGap(569, Short.MAX_VALUE)
                    .addComponent(jPanel13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(175, Short.MAX_VALUE)))
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addGap(76, 76, 76)
                .addComponent(jPanel8, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(244, Short.MAX_VALUE))
            .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel6Layout.createSequentialGroup()
                    .addContainerGap(21, Short.MAX_VALUE)
                    .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(293, Short.MAX_VALUE)))
            .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel6Layout.createSequentialGroup()
                    .addContainerGap(75, Short.MAX_VALUE)
                    .addComponent(jPanel13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(243, Short.MAX_VALUE)))
        );

        add(jPanel6);

        jPanel1.setOpaque(false);

        jLabel1.setFont(new java.awt.Font("Lucida Grande", 1, 14)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(255, 255, 255));
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jLabel1FocusGained(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 829, Short.MAX_VALUE)
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                    .addContainerGap(14, Short.MAX_VALUE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 799, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(16, Short.MAX_VALUE)))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 360, Short.MAX_VALUE)
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                    .addContainerGap(25, Short.MAX_VALUE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(304, Short.MAX_VALUE)))
        );

        add(jPanel1);

        jPanel2.setOpaque(false);

        classListTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null}
            },
            new String [] {
                "Field", "Class Number", "Title", "Type", "Section", "Semester", "Year"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Integer.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.Integer.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        classListTable.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                classListTableFocusLost(evt);
            }
        });
        classListTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                classListTableMouseClicked(evt);
            }
        });
        classListTableScrollPane.setViewportView(classListTable);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 829, Short.MAX_VALUE)
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                    .addContainerGap(40, Short.MAX_VALUE)
                    .addComponent(classListTableScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 754, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(35, Short.MAX_VALUE)))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 360, Short.MAX_VALUE)
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                    .addContainerGap(66, Short.MAX_VALUE)
                    .addComponent(classListTableScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 206, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(88, Short.MAX_VALUE)))
        );

        add(jPanel2);

        jPanel17.setOpaque(false);

        jPanel18.setOpaque(false);

        jLabel8.setIcon(new javax.swing.ImageIcon(getClass().getResource("/mothershipattendance/Image/returnButton25x25.png"))); // NOI18N
        jLabel8.setToolTipText("<html><center>Press this Button to Return Back<br></br>to the Table Type Selection Screen.</center></html>");
        jLabel8.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel8MouseClicked(evt);
            }
        });

        jLabel9.setIcon(new javax.swing.ImageIcon(getClass().getResource("/mothershipattendance/Image/fullreturn.png"))); // NOI18N
        jLabel9.setToolTipText("<html><center>Click this Button to Return to<br></br>the Starting Class Selection Screen.</center></html>");
        jLabel9.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel9MouseClicked(evt);
            }
        });

        javax.swing.GroupLayout jPanel18Layout = new javax.swing.GroupLayout(jPanel18);
        jPanel18.setLayout(jPanel18Layout);
        jPanel18Layout.setHorizontalGroup(
            jPanel18Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 85, Short.MAX_VALUE)
            .addGroup(jPanel18Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel18Layout.createSequentialGroup()
                    .addContainerGap()
                    .addComponent(jLabel8)
                    .addContainerGap(54, Short.MAX_VALUE)))
            .addGroup(jPanel18Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel18Layout.createSequentialGroup()
                    .addContainerGap(41, Short.MAX_VALUE)
                    .addComponent(jLabel9)
                    .addContainerGap(19, Short.MAX_VALUE)))
        );
        jPanel18Layout.setVerticalGroup(
            jPanel18Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 44, Short.MAX_VALUE)
            .addGroup(jPanel18Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel18Layout.createSequentialGroup()
                    .addContainerGap(9, Short.MAX_VALUE)
                    .addComponent(jLabel8)
                    .addContainerGap(10, Short.MAX_VALUE)))
            .addGroup(jPanel18Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel18Layout.createSequentialGroup()
                    .addContainerGap(9, Short.MAX_VALUE)
                    .addComponent(jLabel9)
                    .addContainerGap(10, Short.MAX_VALUE)))
        );

        javax.swing.GroupLayout jPanel17Layout = new javax.swing.GroupLayout(jPanel17);
        jPanel17.setLayout(jPanel17Layout);
        jPanel17Layout.setHorizontalGroup(
            jPanel17Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 829, Short.MAX_VALUE)
            .addGroup(jPanel17Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel17Layout.createSequentialGroup()
                    .addContainerGap(42, Short.MAX_VALUE)
                    .addComponent(jPanel18, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(702, Short.MAX_VALUE)))
        );
        jPanel17Layout.setVerticalGroup(
            jPanel17Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 360, Short.MAX_VALUE)
            .addGroup(jPanel17Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel17Layout.createSequentialGroup()
                    .addContainerGap(287, Short.MAX_VALUE)
                    .addComponent(jPanel18, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(29, Short.MAX_VALUE)))
        );

        add(jPanel17);

        jPanel12.setOpaque(false);

        allStudentsTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null}
            },
            new String [] {
                "Field", "Class Number", "Title", "Type", "Section", "Semester", "Year"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Integer.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.Integer.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        allStudentsTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                allStudentsTableMouseClicked(evt);
            }
        });
        allStudentsTableScrollPane.setViewportView(allStudentsTable);

        javax.swing.GroupLayout jPanel12Layout = new javax.swing.GroupLayout(jPanel12);
        jPanel12.setLayout(jPanel12Layout);
        jPanel12Layout.setHorizontalGroup(
            jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 829, Short.MAX_VALUE)
            .addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel12Layout.createSequentialGroup()
                    .addContainerGap(40, Short.MAX_VALUE)
                    .addComponent(allStudentsTableScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 754, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(35, Short.MAX_VALUE)))
        );
        jPanel12Layout.setVerticalGroup(
            jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 360, Short.MAX_VALUE)
            .addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel12Layout.createSequentialGroup()
                    .addContainerGap(66, Short.MAX_VALUE)
                    .addComponent(allStudentsTableScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 206, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(88, Short.MAX_VALUE)))
        );

        add(jPanel12);

        jPanel3.setOpaque(false);

        jButton1.setFont(new java.awt.Font("Lucida Grande", 1, 13)); // NOI18N
        jButton1.setText("Add Student to Class");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 829, Short.MAX_VALUE)
            .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                    .addContainerGap(594, Short.MAX_VALUE)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 198, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(37, Short.MAX_VALUE)))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 360, Short.MAX_VALUE)
            .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                    .addContainerGap(291, Short.MAX_VALUE)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(30, Short.MAX_VALUE)))
        );

        add(jPanel3);

        jPanel15.setOpaque(false);

        jButton2.setFont(new java.awt.Font("Lucida Grande", 1, 13)); // NOI18N
        jButton2.setText("Add Student to Class");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton7.setFont(new java.awt.Font("Lucida Grande", 1, 13)); // NOI18N
        jButton7.setText("Remove Student From Class");
        jButton7.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jButton7FocusLost(evt);
            }
        });
        jButton7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton7ActionPerformed(evt);
            }
        });

        jLabel3.setIcon(new javax.swing.ImageIcon(getClass().getResource("/mothershipattendance/Image/returnButton25x25.png"))); // NOI18N
        jLabel3.setToolTipText("<html><center>Click this Button to Return<br></br>to Table Type Selection Screen.</center></html>");
        jLabel3.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel3MouseClicked(evt);
            }
        });

        jLabel10.setIcon(new javax.swing.ImageIcon(getClass().getResource("/mothershipattendance/Image/fullreturn.png"))); // NOI18N
        jLabel10.setToolTipText("<html><center>Click this Button to Return to<br></br>the Starting Class Selection Screen.</center></html>");
        jLabel10.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel10MouseClicked(evt);
            }
        });

        javax.swing.GroupLayout jPanel15Layout = new javax.swing.GroupLayout(jPanel15);
        jPanel15.setLayout(jPanel15Layout);
        jPanel15Layout.setHorizontalGroup(
            jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 829, Short.MAX_VALUE)
            .addGroup(jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel15Layout.createSequentialGroup()
                    .addContainerGap(594, Short.MAX_VALUE)
                    .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 198, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(37, Short.MAX_VALUE)))
            .addGroup(jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel15Layout.createSequentialGroup()
                    .addContainerGap(41, Short.MAX_VALUE)
                    .addComponent(jButton7, javax.swing.GroupLayout.PREFERRED_SIZE, 266, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(522, 522, 522)))
            .addGroup(jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel15Layout.createSequentialGroup()
                    .addContainerGap(525, Short.MAX_VALUE)
                    .addComponent(jLabel3)
                    .addContainerGap(279, Short.MAX_VALUE)))
            .addGroup(jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel15Layout.createSequentialGroup()
                    .addContainerGap(561, Short.MAX_VALUE)
                    .addComponent(jLabel10, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(240, Short.MAX_VALUE)))
        );
        jPanel15Layout.setVerticalGroup(
            jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 360, Short.MAX_VALUE)
            .addGroup(jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel15Layout.createSequentialGroup()
                    .addContainerGap(291, Short.MAX_VALUE)
                    .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(30, Short.MAX_VALUE)))
            .addGroup(jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel15Layout.createSequentialGroup()
                    .addContainerGap(291, Short.MAX_VALUE)
                    .addComponent(jButton7, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(31, 31, 31)))
            .addGroup(jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel15Layout.createSequentialGroup()
                    .addContainerGap(292, Short.MAX_VALUE)
                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(34, Short.MAX_VALUE)))
            .addGroup(jPanel15Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel15Layout.createSequentialGroup()
                    .addContainerGap(294, Short.MAX_VALUE)
                    .addComponent(jLabel10, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(35, Short.MAX_VALUE)))
        );

        add(jPanel15);

        jPanel4.setOpaque(false);

        jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/mothershipattendance/Image/PanelBackdrop829x360.png"))); // NOI18N
        jLabel2.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jLabel2FocusGained(evt);
            }
        });
        jLabel2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel2MouseClicked(evt);
            }
        });

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 829, Short.MAX_VALUE)
            .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 360, Short.MAX_VALUE)
            .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        add(jPanel4);

        javax.swing.GroupLayout jPanel16Layout = new javax.swing.GroupLayout(jPanel16);
        jPanel16.setLayout(jPanel16Layout);
        jPanel16Layout.setHorizontalGroup(
            jPanel16Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 53, Short.MAX_VALUE)
        );
        jPanel16Layout.setVerticalGroup(
            jPanel16Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 53, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 829, Short.MAX_VALUE)
            .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel5Layout.createSequentialGroup()
                    .addContainerGap(544, Short.MAX_VALUE)
                    .addComponent(jPanel16, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(232, Short.MAX_VALUE)))
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 360, Short.MAX_VALUE)
            .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel5Layout.createSequentialGroup()
                    .addContainerGap(291, Short.MAX_VALUE)
                    .addComponent(jPanel16, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(16, Short.MAX_VALUE)))
        );

        add(jPanel5);
    }// </editor-fold>//GEN-END:initComponents

    private void jComboBox1FocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jComboBox1FocusGained
        
    }//GEN-LAST:event_jComboBox1FocusGained

    private void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown
        // Retrieve the Current Instance of the MainScreen Class
        // This is done so that we can invoke changes upon the
        // Management Tab JPanel Form Instances Located Within
        // the Management Tab of the MainScreen Class.
        main = classInstanceTracker.getMainScreenInstance();
    }//GEN-LAST:event_formComponentShown

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // This Button is Responsible For Adding a Student to the
        // currently selected class during the All Students Table
        // Segment.
        
        try {
            // Pull the Selected Class From ClassType JComboBox
            classType = jComboBox1.getItemAt(jComboBox1.getSelectedIndex());

            // Create new Instance of the Add Student Confirmation Message Class.
            AddStudentConfirmationMessage ascm = new AddStudentConfirmationMessage(1, -1);
            // Create HTML Formatted Message to be Displayed on JFrame Window Form.
            String formattedHTML = "<html><center>Are you sure you want to add the Student <font color=#0daeef>" + selectedStudentAllStudents.getStudentDisplayName() + "</font> to the Class <font color=#00ec3c>" + classType.getClassTitle() + "</font>?</center></html>";

            // Make the HTML Formatted Text Appear
            // in the Window.
            ascm.jLabel6.setText(formattedHTML);
            // Show the Confirmation Message
            // JFrame Form.
            ascm.setVisible(true);

            // Disable The Components Associated With
            // the All Students Table Until the User
            // Makes a Decision within the Confirmation
            // Message Form.
            enableAllStudentsTableComponents(false);

            // Create A New Thread that is Responsible
            // for waiting for the User to Make a Selection
            // in the Confirmation Form.
            new TaskHandler(3).execute();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void classListTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_classListTableMouseClicked
        if (studentsInClassModel.getRowCount() > 0) {
            
            selectedRowInClass = classListTable.rowAtPoint(evt.getPoint());
            selectedStudentInClass = studentsInClassList.get(selectedRowInClass);
            
            setRemoveStudentFromClassButtonVisible(true);
        }
        
        
    }//GEN-LAST:event_classListTableMouseClicked

    private void jComboBox2FocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jComboBox2FocusGained
        // TODO add your handling code here:
    }//GEN-LAST:event_jComboBox2FocusGained

    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton5ActionPerformed
        selectedViewTypeIndex = jComboBox2.getSelectedIndex();
        
        if (selectedViewTypeIndex == 0) {
            WarningMessageManageStudentAccessSelectValidOption wmmsasvo = new WarningMessageManageStudentAccessSelectValidOption();
            wmmsasvo.setVisible(true);
        }
        else if (selectedViewTypeIndex == 1) {
            // Show Loading Icon in MainScreen Management Tab
            main.jLabel62.setVisible(true);
            
            enableTableTypeSelectionComponents(false);
            
            
            TaskHandler handler = new TaskHandler(1);
            handler.execute();
        }
        else if (selectedViewTypeIndex == 2) {
            
            // Show Loading Icon in MainScreen Management Tab
            main.jLabel62.setVisible(true);
            
            enableTableTypeSelectionComponents(false);
            
            TaskHandler handler = new TaskHandler(2);
            handler.execute();
        }
    }//GEN-LAST:event_jButton5ActionPerformed

    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton6ActionPerformed
        selectedViewTypeIndex = jComboBox1.getSelectedIndex();
        
        if (selectedViewTypeIndex == 0) {
            WarningMessageManageStudentAccessSelectValidOption wmmsasvo = new WarningMessageManageStudentAccessSelectValidOption();
            wmmsasvo.setVisible(true);
        }
        else {
            selectedClassType = jComboBox1.getItemAt(selectedViewTypeIndex);
            resetTableTypeSelectionComponents();

            setClassSelectionComponentsVisible(false);
            setTableTypeSelectionComponentsVisible(true);
        }
    }//GEN-LAST:event_jButton6ActionPerformed

    private void allStudentsTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_allStudentsTableMouseClicked
        if (allStudentsModel.getRowCount() > 0 && defaultTableModelInUseAllStudentsList == false) {
            
            selectedRowAllStudents = allStudentsTable.rowAtPoint(evt.getPoint());
            selectedStudentAllStudents = allStudentsList.get(selectedRowAllStudents);
            
            setAddStudentToClassAllStudentsButtonVisible(true);
        }
    }//GEN-LAST:event_allStudentsTableMouseClicked

    private void jLabel4MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel4MouseClicked
        enableClassSearchComponents(false);
        
        main.jLabel62.setVisible(true);
        
        TaskHandler handler = new TaskHandler(0);
        handler.execute();
    }//GEN-LAST:event_jLabel4MouseClicked

    private void jLabel7MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel7MouseClicked
        jComboBox1.setSelectedIndex(0);
        setTableTypeSelectionComponentsVisible(false);
        setClassSelectionComponentsVisible(true);
        
        jComboBox2.setSelectedIndex(0);
    }//GEN-LAST:event_jLabel7MouseClicked

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        try {
            // Retrieve the ClassType Object Selected Within the JComboBox
            // in the Class Selection Part of the Panel.
            classType = jComboBox1.getItemAt(jComboBox1.getSelectedIndex());

            // In Case Remove Student 
            // Button is Showing, hide it.
            jButton7.setVisible(false);

            // Disable the Table Components Until the User
            // Either Exits from the Add Student Window or
            // Chooses an Option.
            enableStudentsInClassTableComponents(false);
            // Create New Add Student Window Form. This
            // Window Allows for Instructors to find Students
            // By Either thier Usernames or Student ID
            // Numbers, then decide whether or not they
            // want to add them to the Class.
            AddStudentWindow addStudent = new AddStudentWindow(selectedViewTypeIndex, classType);
            // Show Add Student Window Form.
            addStudent.setVisible(true);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jButton7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton7ActionPerformed
        // Create A New Confirmation Message Form Asking
        // For Student Removal.
        RemoveStudentConfirmationMessage rscm = new RemoveStudentConfirmationMessage();
        // Disable the Components Associated With the
        // Students In Class Table While the Operation
        // Executes.
        enableStudentsInClassTableComponents(false);
        
        // Create A HTML Formatted Message To Be Displayed
        // On the Removal Confirmation Message Form.
        String formattedHtml = "<html><center>Are you sure you want to remove the Student <font color=#00c1ff>" + selectedStudentInClass.getStudentDisplayName() + "</font> from the Class <font color=#00c1ff>" + selectedClassType.getClassTitle() + "</font>? (<font color=#ff0000>Note</font>: <font color=#00ea02>This action will also delete All the Student's Attendance Records Associated with this Class. Additionally, if this is the Last Student within the class, all the Previous Attendance Record Dates will also be deleted.</font>)</center></html>";
        // Set the Text in the JLabel.
        rscm.jLabel6.setText(formattedHtml);
        // Show the JFrame Window
        rscm.setVisible(true);
        
        // Create A Thread that is responsible for
        // waiting for the Users Response.
        TaskHandler handler = new TaskHandler(3);
        // Start the Thread.
        handler.execute();
    }//GEN-LAST:event_jButton7ActionPerformed

    private void jLabel3MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel3MouseClicked
        resetTableTypeSelectionComponents();
        
        setClassStudentListComponentsVisible(false);
        setTableTypeSelectionComponentsVisible(true);
        setRemoveStudentFromClassButtonVisible(false);
        
        CustomJTableModelManagementTabStudents defaultModel = new CustomJTableModelManagementTabStudents(new ArrayList<CustomJTableObjectManageStudentsPanel>());
        classListTable.setModel(defaultModel);
        
        defaultTableModelInUseStudentsInClassList = true;
    }//GEN-LAST:event_jLabel3MouseClicked

    private void jLabel1FocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jLabel1FocusGained
        if (selectedStudentInClass != null && selectedViewTypeIndex == 1) {
            setRemoveStudentFromClassButtonVisible(false);
            selectedStudentInClass = null;
        }
        else if (selectedStudentAllStudents != null && selectedViewTypeIndex == 2) {
            setAddStudentToClassAllStudentsButtonVisible(false);
            selectedStudentAllStudents = null;
        }
    }//GEN-LAST:event_jLabel1FocusGained

    private void jLabel2FocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jLabel2FocusGained
        setRemoveStudentFromClassButtonVisible(false);
    }//GEN-LAST:event_jLabel2FocusGained

    private void jButton7FocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jButton7FocusLost
        setRemoveStudentFromClassButtonVisible(false);
    }//GEN-LAST:event_jButton7FocusLost

    private void classListTableFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_classListTableFocusLost
        // Ignore
    }//GEN-LAST:event_classListTableFocusLost

    private void jLabel2MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel2MouseClicked
        // Take Focus Away From JTable and Deselect Any Entries
        jLabel2.requestFocusInWindow();
    }//GEN-LAST:event_jLabel2MouseClicked

    private void jLabel8MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel8MouseClicked
        resetTableTypeSelectionComponents();
        
        setAllStudentsListComponentsVisible(false);
        setTableTypeSelectionComponentsVisible(true);
        setAddStudentToClassAllStudentsButtonVisible(false);
        setAllStudentsTableReturnButtonVisible(false);
        
        CustomJTableModelManagementTabStudents defaultModel = new CustomJTableModelManagementTabStudents(new ArrayList<CustomJTableObjectManageStudentsPanel>());
        allStudentsTable.setModel(defaultModel);
        
        defaultTableModelInUseAllStudentsList = true;
    }//GEN-LAST:event_jLabel8MouseClicked

    /**
     *  Full Return Button Within the All Students
     *  Table Shown Segment of the JPanel Form. Clicking
     *  This JLabel Acts as Clicking A Button Which Returns
     *  The User To the Beginning Class Selection Segment
     *  of the Manage Student Access JPanel Form.
     * 
     *  @param evt      The Click Action Performed on The
     *                  JLabel.
     */
    private void jLabel9MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel9MouseClicked
        // Reset the Components in the Table
        // View Type Selection Segment of the JPanel
        resetTableTypeSelectionComponents();
        // Reset the Components in the Class
        // Selection Segment of the JPanel
        resetClassSelectionComponents();
        // In Case the Add Student Button is Visible in the
        // the All Students Table, Hide it.
        setAddStudentToClassAllStudentsButtonVisible(false);
        // Hide the Components Associated With the
        // All Students Table.
        setAllStudentsListComponentsVisible(false);
        // Show the Class Selection Segment
        // of the JPanel Form.
        setClassSelectionComponentsVisible(true);
    }//GEN-LAST:event_jLabel9MouseClicked

    /**
     *  Full Return Button Within the Students In Class
     *  Table Shown Segment of the JPanel Form. Clicking
     *  This JLabel Acts as Clicking A Button Which Returns
     *  The User To the Beginning Class Selection Segment
     *  of the Manage Student Access JPanel Form.
     * 
     *  @param evt      The Click Action Performed on The
     *                  JLabel.
     */
    private void jLabel10MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel10MouseClicked
        // Reset the Components in the Table
        // View Type Selection Segment of the JPanel
        resetTableTypeSelectionComponents();
        // Reset the Components in the Class
        // Selection Segment of the JPanel
        resetClassSelectionComponents();
        // In Case the Add Student Button is Visible in the
        // the All Students Table, Hide it.
        setAddStudentToClassAllStudentsButtonVisible(false);
        // Hide the Components Associated With the
        // Students In Class Table.
        setClassStudentListComponentsVisible(false);
        // Show the Class Selection Segment
        // of the JPanel Form.
        setClassSelectionComponentsVisible(true);
    }//GEN-LAST:event_jLabel10MouseClicked
    
    /**
     *  Method Used to Set the Enablement of the Components
     *  Associated With the Class Search Segment of the Manage
     *  Student Access JPanel Form. Should A Component Be Enabled,
     *  it means that the User can Click and Interact With it. If
     *  its not enabled, then the Component is Unable to
     *  Interacted with.
     * 
     *  @param value        The True or False Value that Determines
     *                      Whether or Not the Component is Enabled.
     */
    public  static void enableClassSearchComponents(boolean value) {
        // Set Enablement of Title JLabel
        jLabel4.setEnabled(value);
        // Set Enablement of Search Button
        jButton6.setEnabled(value);
        // Set Enablement of Class List JComboBox
        jComboBox1.setEnabled(value);
    }
    
    /**
     *  Method Used to Set the Visibility of the Students In
     *  Class Table Remove Student Button That is Shown When A
     *  the User Clicks on a Student Object Entry Within the Table.
     * 
     *  @param value        The True or False Value that Determines
     *                      Whether or Not the Component is Shown.
     */
    public static void setRemoveStudentFromClassButtonVisible(boolean value) {
        // Set the Buttons Visibility.
        jButton7.setVisible(value);
    }
    
    /**
     *  Method Used to Set the Visibility of the All
     *  Students Table Add Student Button That is Shown When A
     *  the User Clicks on a Student Object Entry Within the Table.
     * 
     *  @param value        The True or False Value that Determines
     *                      Whether or Not the Component is Shown.
     */
    public static void setAddStudentToClassAllStudentsButtonVisible(boolean value) {
        // Set the Buttons Visibility.
        jButton1.setVisible(value);
    }
    
    /**
     *  Method Used to Set the Enablement of the Components
     *  Associated With the Table View Type Segment of the Manage
     *  Student Access JPanel Form. Should A Component Be Enabled,
     *  it means that the User can Click and Interact With it. If
     *  its not enabled, then the Component is Unable to
     *  Interacted with.
     * 
     *  @param value        The True or False Value that Determines
     *                      Whether or Not the Component is Enabled.
     */
    public  static void enableTableTypeSelectionComponents(boolean value) {
        // Set Enablement of Title JLabel
        jLabel6.setEnabled(value);
        // Set Enablement of Table Type View
        // JComboBox
        jComboBox2.setEnabled(value);
        // Set Enablement of Return to Previous
        // Segment Button.
        jLabel7.setEnabled(value);
        // Set Enablement of Action Button.
        jButton5.setEnabled(value);
    }
    
    /**
     *  Method Used to Set the Visibility of the Table
     *  View Type Segment Components Which Are Used to
     *  Select Whether the User wishes to see a List of
     *  the Students in the Current Class or A List of
     *  Students not in the Current Class.
     * 
     *  @param value        The True or False Value that Determines
     *                      Whether or Not the Components are Shown.
     */
    public  static void setTableTypeSelectionComponentsVisible(boolean value) {
        // Set Title JLabel Visibility
        jLabel6.setVisible(value);
        // Set Table Type Selection JComboBox Visibility
        jComboBox2.setVisible(value);
        // Set Return to Previous Screen Button
        // Visibility
        jLabel7.setVisible(value);
        // Set Action Button Visibility
        jButton5.setVisible(value);
    }
    
    /**
     *  Method Used to Reset the Table Type Selection
     *  JComboBox Selected Index Value Upon A Return
     *  or Full Return Button Being Clicked.
     */
    public void resetTableTypeSelectionComponents() {
        // Select the First Default Entry
        // Within the JComboBox.
        jComboBox2.setSelectedIndex(0);
    }
    
    /**
     *  Method Used to Set the Visibility of the Students
     *  in Class Table Segment Components. This Method is Used
     *  When An Instructor chooses to return to a previous part of
     *  the JPanel Form, or Calculation's Are Being made on the
     *  Students In Class Table. (E.g. Add Student or Remove Student)
     * 
     *  @param value        The True or False Value that Determines
     *                      Whether or Not the Components are Shown.
     */
    public static void setClassStudentListComponentsVisible(boolean value) {
        // Set Title JLabel Visibility
        jLabel1.setVisible(value);
        // Set Table ScrollPane Object Visibility
        classListTableScrollPane.setVisible(value);
        // Set Table Visibility
        classListTable.setVisible(value);
        // Set Add Student Button Visibility
        jButton2.setVisible(value);
        // Set Return to Table View Type
        // Selection Screen Button Visibility
        jLabel3.setVisible(value);
        // Set Return to Class Selection
        // Screen Button Visibility (Full Return)
        jLabel10.setVisible(value);
    }
    
    /**
     *  Method Used to Set the Visibility of the All
     *  Students Table Segment Components. This Method is Used
     *  When An Instructor chooses to return to a previous part of
     *  the JPanel Form, or Calculation's Are Being made on the
     *  Students In Class Table. (E.g. Add Student to Class)
     * 
     *  @param value        The True or False Value that Determines
     *                      Whether or Not the Components are Shown.
     */
    public void setAllStudentsListComponentsVisible(boolean value) {
        // Set Title JLabel Visibility
        jLabel1.setVisible(value);
        // Set Table ScrollPane Object Visibility
        allStudentsTableScrollPane.setVisible(value);
        // Set Table Visibility
        allStudentsTable.setVisible(value);
        // Set Return to Table View Type
        // Selection Screen Button Visibility
        jLabel8.setVisible(value);
        // Set Return to Class Selection
        // Screen Button Visibility (Full Return)
        jLabel9.setVisible(value);
    }
    
    /**
     *  Method Used to Set the Visibility of the Class
     *  Selection Segment Components Which Are Used to
     *  Select The Class that the User Wishes to Manage
     *  Student Access For.
     * 
     *  @param value        The True or False Value that Determines
     *                      Whether or Not the Components are Shown.
     */
    public void setClassSelectionComponentsVisible(boolean value) {
        // Set Title JLabel Visibility
        jLabel5.setVisible(value);
        // Set Refresh Class List Button Visibility
        jLabel4.setVisible(value);
        // Set Class List JComboBox Visibility
        jComboBox1.setVisible(value);
        // Set Action Button Visibility
        jButton6.setVisible(value);
    }
    
    /**
     *  Method used to Set the Visibility of the All Students Table
     *  Segment's Return and Full Return Buttons. 
     * 
     *  @param value        The True or False Value that Determines
     *                      Whether or Not the Components are Shown.
     */
    public void setAllStudentsTableReturnButtonVisible(boolean value) {
        // Set Return Button Visibility
        jLabel8.setVisible(value);
        // Set Full Return Button Visibility.
        jLabel9.setVisible(value);
    }
    
    /**
     *  Method Used to Reset the Index of the 
     *  Class Selection JComboBox. This Method is
     *  Called Whenever the User Clicks a Return or
     *  Full Return Button.
     */
    public void resetClassSelectionComponents() {
        // Set the Class Selection JComboBox
        // Index to the Default ClassType Object.
        jComboBox1.setSelectedIndex(0);
    }
    
    public int getRemoveStudentChoice() {
        return removeStudentChoice;
    }
    
    public void setRemoveStudentChoice(int value) {
        removeStudentChoice = value;
    }
    
    public void resetInClassTableContents() {
        
        setClassStudentListComponentsVisible(false);
        main.jLabel62.setVisible(true);
        
        TaskHandler handler = new TaskHandler(4);
        handler.execute();
    }
    
    public static void enableAllStudentsTableComponents(boolean value) {
        allStudentsTableScrollPane.setEnabled(value);
        allStudentsTable.setEnabled(value);
        jButton1.setEnabled(value);
        jLabel8.setEnabled(value);
        jLabel1.setEnabled(value);
        jLabel9.setEnabled(value);
    }
    
    public static void enableStudentsInClassTableComponents(boolean value) {
        classListTableScrollPane.setEnabled(value);
        classListTable.setEnabled(value);
        jButton2.setEnabled(value);
        jButton7.setEnabled(value);
        jLabel3.setEnabled(value);
        jLabel1.setEnabled(value);
        jLabel10.setEnabled(value);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    public static javax.swing.JTable allStudentsTable;
    public static javax.swing.JScrollPane allStudentsTableScrollPane;
    public static javax.swing.JTable classListTable;
    public static javax.swing.JScrollPane classListTableScrollPane;
    public static javax.swing.JButton jButton1;
    public static javax.swing.JButton jButton2;
    public static javax.swing.JButton jButton5;
    public static javax.swing.JButton jButton6;
    public static javax.swing.JButton jButton7;
    public static javax.swing.JComboBox<ClassType> jComboBox1;
    public static javax.swing.JComboBox<String> jComboBox2;
    public static javax.swing.JLabel jLabel1;
    public static javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel2;
    public static javax.swing.JLabel jLabel3;
    public static javax.swing.JLabel jLabel4;
    public static javax.swing.JLabel jLabel5;
    public static javax.swing.JLabel jLabel6;
    public static javax.swing.JLabel jLabel7;
    public static javax.swing.JLabel jLabel8;
    public static javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel10;
    private javax.swing.JPanel jPanel11;
    private javax.swing.JPanel jPanel12;
    private javax.swing.JPanel jPanel13;
    private javax.swing.JPanel jPanel14;
    private javax.swing.JPanel jPanel15;
    private javax.swing.JPanel jPanel16;
    private javax.swing.JPanel jPanel17;
    private javax.swing.JPanel jPanel18;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JPanel jPanel8;
    private javax.swing.JPanel jPanel9;
    // End of variables declaration//GEN-END:variables
    
    public static ArrayList<Student> studentsInClassList = new ArrayList<>();
    public static ArrayList<CustomJTableObjectManageStudentsPanel> rowDataListStudentsInClass = new ArrayList<>();
    
    public static ArrayList<Student> allStudentsList = new ArrayList<>();
    public static ArrayList<CustomJTableObjectManageStudentsPanel> rowDataListAllStudents = new ArrayList<>();
    
    public static CustomJTableModelManagementTabStudents studentsInClassModel;
    public static CustomJTableModelManagementTabStudents allStudentsModel;
    
    public Student selectedStudentInClass;
    public Student selectedStudentAllStudents;
    
    public int selectedRowInClass;
    public int selectedRowAllStudents;
    
    public int selectedViewTypeIndex;
    
    public DatabaseManagerMySQL manager = new DatabaseManagerMySQL();
    public TrackerObject tracker = new TrackerObject();
    public ServerInformationTracker serverTracker = new ServerInformationTracker();
    public ClassInstanceInformationTracker classInstanceTracker = new ClassInstanceInformationTracker();
    public static ClassType selectedClassType;
    
    public MainScreen main;
    public int removeStudentChoice = 0;
    
    public static boolean defaultTableModelInUseStudentsInClassList = true;
    public static boolean defaultTableModelInUseAllStudentsList = true;
    
    public Student defaultStudentEntry = new Student(-1, 0, "", "", "", "", "", "", "", "", "", "", "", "", "");
    public TaskHandler removeStudentThread;
    public MessageResponseTracker messageResponseTracker = new MessageResponseTracker();
    
    public TaskHandler resetInClassTable;
    
    public ClassType classType;
    
    /*
     *  LoadingScreenController is a SwingWorker Class whose
     *  doInBackground() Method is invoked upon calling the execute()
     *  method in the main class. A SwingWorker Class is the only
     *  way to safely create a seperate thread that interacts with
     *  the main EventQueue class. Should you try to invoke change to the GUI
     *  object from a non EventQueue related class, it can cause
     *  unforseen nonrepeatable errors in the programs execution.
     *
     */
    public class TaskHandler extends SwingWorker<Void,Void> {
        
        public int task;
        public boolean lastStudent;

        public TaskHandler(int value) {
            task = value;
        }
        
        public boolean getLastStudentBooleanValue() {
            return lastStudent;
        }
        
        public void setLastStudentBooleanValue(boolean value) {
            lastStudent = value;
        }
        
        // Method for Seperate EventQueue Thread
        // to Execute.
        @Override
        protected Void doInBackground() throws Exception {
            
            // Reload the Starting Class Selection List JComboBox
            // should the Refresh Classes Button (JLabel4) Be Clicked.
            if (task == 0) {
                // Retrieve a List of All the Class Row ID Numbers
                // Associated with the Current Instructor.
                ArrayList<Integer> classIDs = manager.getInstructorClassListIDs(tracker.getCurrentInstructorInformation().getInstructorID());
                // Use the previously created List in order to
                // retrieve the ClassType Objects Associated with
                // each Row ID Number.
                ArrayList<ClassType> classes = manager.getInstructorClassList(classIDs);

                // Create A Custom Default No Classes ClassType. This
                // ClassType will be placed Within the JComboBox should
                // the Current Instructor not have any Classes Associated
                // with his or her Account.
                ClassType noClassesClassType = new ClassType(0, "NULL", 0, "--------- No Associated Classes -------- ", "", "", "", "Lecture", "", 0, 0);
                // Create A Custom Default ClassType. This
                // ClassType will be placed at the Top of the
                // JComboBox Component And Act as a Default Starting
                // Option When the JComboBox is Shown. (Index: 0)
                ClassType defaultClassTypeUpdateClassInformationJPanel = new ClassType(0, "NULL", 0, "---------------------------------------- ", "", "", "", "Lecture", "", 0, 0);

                // Create the ArrayList That Will Be Passed in to the
                // JComboBox in order to Populate it. Seeing as There May
                // Multiple Classes Which Have the Exact Same Title,
                //
                // (Ex. "English I" or "Chemistry II")
                // 
                // We will Iterate Through the Classes ArrayList Retrieved
                // And Created Earlier to see if There Are Any Associated
                // Classes With Duplicate Titles. If so, we will set the
                // Duplicate Status Boolean Value to True Within the ClassType
                // Object. This means that when the JComboBox Calls the toString()
                // Method on the Current ArrayList Object, Instead of Just
                // Displaying the Class's Title, it will also display the
                // Class's Semester, Year, and Section to let the User
                // Easily Differentiate Between the Classes.
                ArrayList<ClassType> classTypeList = new ArrayList<>();

                // Iterate Through the List of Classes.
                for (int i = 0; i < classes.size(); i++) {
                    // If this is the First Iteration
                    // Just Add the First ClassType Object
                    // to the Comparison ArrayList.
                    if (i == 0) {
                        // Add the Current Class to The
                        // Comparison ArrayList.
                        classTypeList.add(classes.get(i));
                    }
                    // If this is not the First Iteration
                    // Execute.
                    else {
                        // Loop through the Comparison ArrayList
                        // and Compare Each Value to the Values
                        // in the original ClassType ArrayList. If
                        // an Entry has the same Class Title As Another
                        // Class in the List, marke the Duplicate Status
                        // Boolean Within the ClassType Object As True.
                        for (int j = 0; j < classTypeList.size(); j++) {
                            // Compare the Current ClassType Title from the Original
                            // List to the Current ClassType Comparison List Entry.If the
                            // Two Classes Have the Same Titles, Mark the Duplicate Status
                            // Boolean Value As True in Both ArrayList.
                            if (classTypeList.get(j).getClassTitle().equalsIgnoreCase(classes.get(i).getClassTitle())) {
                                // Set the Duplicate Status Boolean Value to True
                                // in the Original List should the Current
                                // Class Title Be The Same.
                                classes.get(i).setDuplicateStatus(true);
                                // Set the Duplicate Status Boolean Value to True
                                // in the Comparison List should the Current
                                // Class Title Be The Same.
                                classTypeList.get(j).setDuplicateStatus(true);

                            }
                        }

                        // Add the Current Entry from the Original ClassType
                        // ArrayList to the Comparison List.
                        classTypeList.add(classes.get(i));
                    }
                }

                // If the Comparison ArrayList Created Previously
                // has no Entries Within it, add the No Classes
                // Null ClassType Created Earlier. 
                if (classTypeList.isEmpty()) {
                    // Add the Null ClassType to Start of List.
                    classTypeList.add(0, noClassesClassType);
                }
                // If the Comparison ArrayList Created Previously
                // has Entries Within it, add the Default Class
                // ClassType Created Earlier to the Start of the List.
                else {
                    // Add the Default ClassType to Start of List.
                    classTypeList.add(0, defaultClassTypeUpdateClassInformationJPanel);
                }

                // Create New DefaultComboBoxModel Object Using the Comparison List
                // Which will be used to Populate the JComboBox's New List.
                DefaultComboBoxModel modelBoxOne = new DefaultComboBoxModel(classTypeList.toArray());
                // Set the Previously Created Model as the
                // Model for the ClassType JComboBox
                jComboBox1.setModel(modelBoxOne);
                // Make Sure the First Index is Selected
                // Upon Being Shown.
                jComboBox1.setSelectedIndex(0);
                
                // Ensure that the Return to Previous Screen Button
                // (JLabel8) is hidden seeing as its not supposed to
                // be shown in this segment of the Manage Student Access
                // Selection Process. There is no Previous Screen To Return
                // to at this Point in the JPanel Form.
                jLabel8.setVisible(false);

                // Seeing as We Have Now Finished Repopulating the
                // Class Selection JComboBox, Hide the Loading Emblem
                // GIF Image in the MainScreen Class Which Appears over
                // the JPanel Forms.
                main.jLabel62.setVisible(false);
        
                // Seeing as We Have Now Finished Repopulating the
                // Class Selection JComboBox, Renable it Along with
                // all of the Other Components that Are Part of the
                // Class Selection Process in the Manage Student Access
                // JPanel Form.
                enableClassSearchComponents(true);
            }
            // Create Initial Students In Class Table After
            // View Table Type Button is Pressed
            else if (task == 1) {
                
                // Get a List of the Current Students within the Class
                studentsInClassList = manager.getStudentsAssociatedWithClass(selectedClassType.getClassID());
                // Reset Students in Class Table ArrayList.
                rowDataListStudentsInClass = new ArrayList<CustomJTableObjectManageStudentsPanel>();
                
                // Execute if the Currently Selected Class Has No
                // Students within its Class Roster
                if (studentsInClassList.isEmpty()) {
                    
                    // Create the New Table Model Using an Empty List
                    studentsInClassModel = new CustomJTableModelManagementTabStudents(rowDataListStudentsInClass);
                    // Set the Table to show A Blank Model which will
                    // be automatically resized to fit the Container ScrollPane.
                    classListTable.setModel(studentsInClassModel);

                    // Disable Column Reordering so the User wont violate
                    // or change the Table's Settings.
                    classListTable.getTableHeader().setReorderingAllowed(false);

                    // Show that the Default Table Model is not currently in use.
                    // This is done to Let the Program know when to show or hide
                    // components upon click.
                    defaultTableModelInUseStudentsInClassList = false;

                    // In this next section of code, we will create multiple Custom Cell
                    // Renderer Objects. These Objects are responsible for changing the Overall
                    // Appearance of the Cells (Such as Background and Vertical / Horizontal Data Alignment)
                    // along with Changing things such as Data Font Type, Size, and Color. There are Two
                    // Different Types of Cell Renderers. One for the Header or "Title" Cells of A Column
                    // while the other is used to manipulate the contents of the Data Cells Contained
                    // Underneath.
                    
                    // Create A Custom Cell Render which will be used on each of the
                    // Data Cell Rows within the Table. This Renderer will set the Font
                    // to the Regular "Lucida Grande" Font and Align the Contained text
                    // within the Center of the Cell.
                    DefaultTableCellRenderer renderer = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 0, 13));
                             // Return the Custom Cell Renderer Object
                             // which will be assigned to all Data Cells
                             // within the Table.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Black and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererBlack = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Black.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(0, 0, 0));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Royal Blue and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererRoyalBlue = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Royal Blue.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(51, 153, 255));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Set the Height of Each Row within the Table
                    // to 100 Pixels. This is done so that the Contained Data
                    // is more Seperated and thus easier to Read.
                    classListTable.setRowHeight(100);

                    // Assign the Data Cell Renderer created earlier to Columns (1 - 6) Within
                    // the Table. Seeing as the First Column will contain the Student's Associated
                    // Profile Image, we will not assign a Cell Renderer to the Column. Should we
                    // Assign the cell Renderer to Column 0, a filepath to the Student's Profile Picture
                    // will be shown instead of the Actual Desired Image.
                    
                    // Assign Data Cell Render to Column 1 Within the Table.
                    classListTable.getColumnModel().getColumn(1).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 2 Within the Table.
                    classListTable.getColumnModel().getColumn(2).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 3 Within the Table.
                    classListTable.getColumnModel().getColumn(3).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 4 Within the Table.
                    classListTable.getColumnModel().getColumn(4).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 5 Within the Table.
                    classListTable.getColumnModel().getColumn(5).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 6 Within the Table.
                    classListTable.getColumnModel().getColumn(6).setCellRenderer(renderer);

                    // Assign the Custom Cell Header Renderer Objects to each of the Columns Within
                    // the Table. We will Alternate in Assigning the Black and Royal Blue HeaderRenderer Objects
                    // by one cell each. This is done to make the Table more Aesthetically Pleasing in
                    // addition to helping with Overall Data Readability.
                    
                    // Assign the Custom Black Header Render Object to Column 0 Within the Table.
                    classListTable.getColumnModel().getColumn(0).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 1 Within the Table.
                    classListTable.getColumnModel().getColumn(1).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 2 Within the Table.
                    classListTable.getColumnModel().getColumn(2).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 3 Within the Table.
                    classListTable.getColumnModel().getColumn(3).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 4 Within the Table.
                    classListTable.getColumnModel().getColumn(4).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 5 Within the Table.
                    classListTable.getColumnModel().getColumn(5).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 6 Within the Table.
                    classListTable.getColumnModel().getColumn(6).setHeaderRenderer(headerRendererBlack);

                    // Seeing as we are using an Empty ArrayList to Form this Table, the
                    // Width of all the Column Header Cells Combined won't be long enough to fill
                    // the entirety of the ScrollPane holding our JTable. Thus, we Assign the 
                    // AUTO_RESIZE_ALL_COLUMNS Integer to the JTable setAutoResizeMode() method.
                    // This will Automatically Resize All of the Columns withing the Table to
                    // Fill the Length of the ScrollPane. This is done for Aesthetic Improvement
                    // to the Program.
                    classListTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
                    
                    // Hide the Loading Icon in MainScreen Management Tab
                    // seeing as we have now retrieved the Student Data and
                    // used it to Create our Table.
                    main.jLabel62.setVisible(false);

                    // Hide the Table View Type Selection Components
                    // From the Users View.
                    setTableTypeSelectionComponentsVisible(false);
                    // Ensure that the Remove Student From Class
                    // Button is not visible once the Table is shown.
                    // This Button should only appear when the Instructor
                    // clicks upon a Student within the Students in Class
                    // Table.
                    setRemoveStudentFromClassButtonVisible(false);
                    // Seeing as we now have our Table Completely made
                    // and the Loading Icon has been hidden. Renable the
                    // Table View Type Selection Components.
                    enableTableTypeSelectionComponents(true);

                    // Create an HTML Formatted Text String for the Title
                    // JLabel Located Above the Students in Class Table.
                    String formattedHtmlClassTitle = "<html><center><font color=#0093ff>" + selectedClassType.getClassTitle() + "</font> (<font color=#ff0000>Students In Class</font>):</center></html>";
                    // Make the JLabel Show  the Title of the Currently
                    // Selected Class in a Royal Blue Color.
                    jLabel1.setText(formattedHtmlClassTitle);

                    // Show the Students in Class Table and its Accompanying
                    // Components Seeing as the Table's Model has been Set
                    // and everything else has finished.
                    setClassStudentListComponentsVisible(true);
                }
                // Execute if the Currently Selected Class Already
                // has Students Present within its Roster.
                else {
                    
                    // The CustomJTableModelManagementTabStudents JTable Object Requires
                    // An ArrayList or List Object to be Passed in as its Parameter. However
                    // This List Object must in turn contain Custom Objects which will be
                    // Automatically used to Display the Data Within the Table. Thus, in this
                    // for loop, we convert the Student ArrayList retrived from the Remote
                    // Database into a new ArrayList of CustomJTableObjectManageStudentsPanel Objects,
                    // each of which contains a variable holding the desired Data Type that corresponds
                    // to the Column Locations Within the Table.
                    for (int i = 0; i < studentsInClassList.size(); i++) {

                        // Get the Student's Small Profile Image FilePath String. This will be used in
                        // an ImageIcon conversion momentarily.
                        String image = "" + studentsInClassList.get(i).getStudentProfileImageSmall();
                        // Retrieve the Student's Display Name which is a Combination of thier
                        // First and Last Names.
                        String name = "  " + studentsInClassList.get(i).getStudentDisplayName() + "  ";
                        // Retrieve the Student's Associated Username for thier Account.
                        String username = "  " + studentsInClassList.get(i).getStudentUsername() + "  ";
                        // Retrieve the Student's Email Address 
                        // associated with thier Account.
                        String email = "";
                        // Retrieve the Student's Phone Number 
                        // associated with thier Account.
                        String phone = "";
                        // Retrieve the Student's Physical Address 
                        // associated with thier Account.
                        String address = "";

                        // If the Student's Email Address Field is Empty, set the JTable Display
                        // Value to N/A (Not Available). This will also be serpated by two spaces on
                        // both sides in order to distance the width between column information in the
                        // Table. This is done to improve Application Aestheics and Table Readability.
                        if (studentsInClassList.get(i).getStudentEmail().equalsIgnoreCase("")) {
                            // Assign the Not Available Value
                            // to the String.
                            email = "  N/A  ";
                        }
                        else {
                            // If the Email Address Field is not empty, assign the actual value
                            // once again seperated on both sides by two spaces.
                            email = "  " + studentsInClassList.get(i).getStudentEmail() + "  ";
                        }
                        
                        // If the Student's Phone Number Field is Empty, set the JTable Display
                        // Value to N/A (Not Available). This will also be serpated by two spaces on
                        // both sides in order to distance the width between column information in the
                        // Table. This is done to improve Application Aestheics and Table Readability.
                        if (studentsInClassList.get(i).getStudentPhone().equalsIgnoreCase("") || studentsInClassList.get(i).getStudentPhone().equalsIgnoreCase("Default")) {
                            // Assign the Not Available Value
                            // to the String.
                            phone = "  N/A  ";
                        }
                        else {
                            // If the Phone Number Field is not empty, assign the actual value
                            // once again seperated on both sides by two spaces.
                            phone = "  " + studentsInClassList.get(i).getStudentPhone() + "  ";
                        }

                        // If the Student's Physical Address Field is Empty, set the JTable Display
                        // Value to No Address Available. This will also be serpated by two spaces on
                        // both sides in order to distance the width between column information in the
                        // Table. This is done to improve Application Aestheics and Table Readability.
                        if (studentsInClassList.get(i).getStudentAddress().equalsIgnoreCase("")) {
                            // Assign the No Address Available Value
                            // to the String.
                            address = "  No Address Available  ";
                        }
                        else {
                            // If the Physical Address Field is not empty, assign the actual value
                            // once again seperated on both sides by two spaces.
                            address = "  " + studentsInClassList.get(i).getStudentAddress() + "  ";
                        }
                        
                        // Use the previously calculated Values to Form A New CustomJTableObjectManageStudentsPanel
                        // and add it to the rowDataListStudentsInClass ArrayList which will be used later to create
                        // Student's In Class JTable Object.
                        rowDataListStudentsInClass.add(new CustomJTableObjectManageStudentsPanel(new javax.swing.ImageIcon(getClass().getResource(image)), name, studentsInClassList.get(i).getStudentIdentificationNumber(), username, email, phone, address));
                    }
                    
                    // Once the Loop has finished Executing, Use the new rowDataListStudentsInClass ArrayList
                    // to create the Student's In Class Table Model.
                    studentsInClassModel = new CustomJTableModelManagementTabStudents(rowDataListStudentsInClass);
                    // Set this new model to our classListTable JTable's
                    // custom model field.
                    classListTable.setModel(studentsInClassModel);

                    // Disable Table Column Reordering. This is done to prevent
                    // the user from Accidently altering or violating the Table's
                    // set Properties.
                    classListTable.getTableHeader().setReorderingAllowed(false);

                    // Seeing as we are using a Custom Model for our Student's In
                    // Class JTable, we will set the Default Table Model Boolean
                    // Value to Zero. This is done to let other event Queue Threads
                    // know when to Show / Hide or Enable / Disable other Components.
                    defaultTableModelInUseStudentsInClassList = false;

                    
                    // In this next section of code, we will create multiple Custom Cell
                    // Renderer Objects. These Objects are responsible for changing the Overall
                    // Appearance of the Cells (Such as Background and Vertical / Horizontal Data Alignment)
                    // along with Changing things such as Data Font Type, Size, and Color. There are Two
                    // Different Types of Cell Renderers. One for the Header or "Title" Cells of A Column
                    // while the other is used to manipulate the contents of the Data Cells Contained
                    // Underneath.
                    
                    // Create A Custom Cell Render which will be used on each of the
                    // Data Cell Rows within the Table. This Renderer will set the Font
                    // to the Regular "Lucida Grande" Font and Align the Contained text
                    // within the Center of the Cell.
                    DefaultTableCellRenderer renderer = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 0, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Data Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Black and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererBlack = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Black.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(0, 0, 0));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Royal Blue and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererRoyalBlue = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Royal Blue.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(51, 153, 255));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Set the Height of Each Row within the Table
                    // to 100 Pixels. This is done so that the Contained Data
                    // is more Seperated and thus easier to Read.
                    classListTable.setRowHeight(100);

                    // Assign the Data Cell Renderer created earlier to Columns (1 - 6) Within
                    // the Table. Seeing as the First Column will contain the Student's Associated
                    // Profile Image, we will not assign a Cell Renderer to the Column. Should we
                    // Assign the cell Renderer to Column 0, a filepath to the Student's Profile Picture
                    // will be shown instead of the Actual Desired Image.

                    // Assign Data Cell Render to Column 1 Within the Table.
                    classListTable.getColumnModel().getColumn(1).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 2 Within the Table.
                    classListTable.getColumnModel().getColumn(2).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 3 Within the Table.
                    classListTable.getColumnModel().getColumn(3).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 4 Within the Table.
                    classListTable.getColumnModel().getColumn(4).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 5 Within the Table.
                    classListTable.getColumnModel().getColumn(5).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 6 Within the Table.
                    classListTable.getColumnModel().getColumn(6).setCellRenderer(renderer);

                    // Assign the Custom Cell Header Renderer Objects to each of the Columns Within
                    // the Table. We will Alternate in Assigning the Black and Royal Blue HeaderRenderer Objects
                    // by one cell each. This is done to make the Table more Aesthetically Pleasing in
                    // addition to helping with Overall Data Readability.
                    
                    // Assign the Custom Black Header Render Object to Column 0 Within the Table.
                    classListTable.getColumnModel().getColumn(0).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 1 Within the Table.
                    classListTable.getColumnModel().getColumn(1).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 2 Within the Table.
                    classListTable.getColumnModel().getColumn(2).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 3 Within the Table.
                    classListTable.getColumnModel().getColumn(3).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 4 Within the Table.
                    classListTable.getColumnModel().getColumn(4).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 5 Within the Table.
                    classListTable.getColumnModel().getColumn(5).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 6 Within the Table.
                    classListTable.getColumnModel().getColumn(6).setHeaderRenderer(headerRendererBlack);
                
                    // Turn off Auto Resize Mode Within the Table. In the Next Step,
                    // we will Calculate the Desired Width of Each Column by mesauring
                    // the length of the longest piece of Data contained within all the
                    // rows present in the Table. We turn the Auto Resize Mode off so that
                    // the Data is all clearly show to the User.
                    classListTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
                    
                    // Adjust Column Widths According to Largest Piece of Data Contained
                    // within one rows in each column. Loop until all of the Columns have been
                    // searched through and set the Associated Width of the Longest Data Entry
                    // within thier ranks.
                    for (int column = 0; column < classListTable.getColumnCount(); column++)
                    {
                        // Retrive the Table Column Model Object Associated with the Current
                        // Column Number that the loop is on.
                        TableColumn tableColumn = classListTable.getColumnModel().getColumn(column);
                        // Retrieve the Prefered Width of the Column. This is the Actual Width
                        // Associated with the Column Object Within the Table.
                        int preferredWidth = tableColumn.getMinWidth();
                        // Retrieve the Max Width of the Column. This is the Width which the
                        // column may be stretched too should it be required.
                        int maxWidth = tableColumn.getMaxWidth();

                        // Loop through each of the Rows Within the Current Column
                        for (int row = 0; row < classListTable.getRowCount(); row++)
                        {
                            // Retrieve the Cell Renderer Object Associated With the Current
                            // Column and Row Number. This will be used to retrieve the size
                            // information of the Data Contained within the Cell.
                            TableCellRenderer cellRenderer = classListTable.getCellRenderer(row, column);
                            // Convert the Cell Renderer into a Generic Component Object to Retrieve
                            // the Data Size Information.
                            Component c = classListTable.prepareRenderer(cellRenderer, row, column);
                            // Retrieve the Prefered Width of the Components Containing the Data.
                            // The Prefered Width is the current width of the Compononet after all of the
                            // changes we invoked earlier. We then combine this with the Intercell Spacing
                            // Width to get the Length in Pixels of the Data.
                            int width = c.getPreferredSize().width + classListTable.getIntercellSpacing().width;
                            // Get the Maximum Size that the Cell's Width Can Become.
                            preferredWidth = Math.max(preferredWidth, width);

                            // Check to see if the Preferered Width is greater than the
                            // Cells Maximum Visible Dimension Size. If so,
                            // We've exceeded the maximum width, so theres
                            // no need to check other rows.
                            if (preferredWidth >= maxWidth)
                            {
                                // Set the Prefered Width to the Max
                                // Width's Size.
                                preferredWidth = maxWidth;
                                // Break Inner Loop.
                                break;
                            }
                        }

                        // Se the Prefererd Width of the Current Column to
                        // the Maximum Width Required to Fully Display the
                        // longest piece of information.
                        tableColumn.setPreferredWidth(preferredWidth);
                    }

                    // Seeing as We have made changes to the Original Structure
                    // of the JScrollPane Viewport, revalidate the object before repainting
                    // it to the Screen.
                    classListTableScrollPane.revalidate();
                    classListTableScrollPane.repaint();
                    
                    // Seeing as We have made changes to the Original Structure
                    // of the JTable, revalidate the object before repainting
                    // it to the Screen.
                    classListTable.revalidate();
                    classListTable.repaint();
                    
                    // Create Integer Array Variable to Hold the Individual Width's
                    // of each Column now that the resizing operations have been
                    // performed.
                    int[] columnWidths = {0, 0, 0, 0, 0, 0, 0};
                    
                    // Get the Current Width of the First Column.
                    columnWidths[0] = classListTable.getColumnModel().getColumn(0).getPreferredWidth();
                    // Get the Current Width of the Second Column.
                    columnWidths[1] = classListTable.getColumnModel().getColumn(1).getPreferredWidth();
                    // Get the Current Width of the Third Column.
                    columnWidths[2] = classListTable.getColumnModel().getColumn(2).getPreferredWidth();
                    // Get the Current Width of the Forth Column.
                    columnWidths[3] = classListTable.getColumnModel().getColumn(3).getPreferredWidth();
                    // Get the Current Width of the Fifth Column.
                    columnWidths[4] = classListTable.getColumnModel().getColumn(4).getPreferredWidth();
                    // Get the Current Width of the Sixth Column.
                    columnWidths[5] = classListTable.getColumnModel().getColumn(5).getPreferredWidth();
                    // Get the Current Width of the Seventh Column.
                    columnWidths[6] = classListTable.getColumnModel().getColumn(6).getPreferredWidth();
                    
                    // Combine All of the Column Widths to get A Total
                    // Width in pixels. This is done to provide a comparison
                    // value in the next step.
                    int jTableWidth = columnWidths[0] + columnWidths[1] + columnWidths[2] + columnWidths[3] + columnWidths[4] + columnWidths[5] + columnWidths[6];

                    // If The Width of All the Current Columns in the JTable is
                    // Less than the Size of the JScrollPane's Visible Viewport Width, then
                    // resize the Last Column to Fit the Entire ScrollPane Width
                    if (jTableWidth < 754) {
                        // Set JTable Resize Mode to Automatically Resize the Last Column
                        // should the current assortment of the Datat contained within all of
                        // the columns and rows is less in pixel width than the visible
                        // Area of the Container JViewPort.
                        classListTable.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
                    }

                    // Hide the Loading Icon in MainScreen Management Tab
                    // seeing as we have now retrieved the Student Data and
                    // used it to Create our Table.
                    main.jLabel62.setVisible(false);

                    // Hide the Table View Type Selection Components
                    // From the Users View.
                    setTableTypeSelectionComponentsVisible(false);
                    // Ensure that the Remove Student From Class
                    // Button is not visible once the Table is shown.
                    // This Button should only appear when the Instructor
                    // clicks upon a Student within the Students in Class
                    // Table.
                    setRemoveStudentFromClassButtonVisible(false);
                    // Seeing as we now have our Table Completely made
                    // and the Loading Icon has been hidden. Renable the
                    // Table View Type Selection Components.
                    enableTableTypeSelectionComponents(true);

                    // Create an HTML Formatted Text String for the Title
                    // JLabel Located Above the Students in Class Table.
                    String formattedHtmlClassTitle = "<html><center><font color=#0093ff>" + selectedClassType.getClassTitle() + "</font> (<font color=#ff0000>Students In Class</font>):</center></html>";
                    // Make the JLabel Show  the Title of the Currently
                    // Selected Class in a Royal Blue Color.
                    jLabel1.setText(formattedHtmlClassTitle);

                    // Show the Students in Class Table and its Accompanying
                    // Components Seeing as the Table's Model has been Set
                    // and everything else has finished.
                    setClassStudentListComponentsVisible(true);
                }
            }
            // Create All Students Table After
            // View Table Type Button is Pressed
            else if (task == 2) {
                
                System.out.println("Getting Here in the Students Table Repopulate Method 1");
                // Get A List of the Students Associated With
                // the Currently Selected ClassType.
                ArrayList<Student> studentsInClassList = manager.getStudentsAssociatedWithClass(selectedClassType.getClassID());
                // Re-Initialize the All Students Table
                // ArrayList to Remove Any Previous Entries.
                allStudentsList = new ArrayList<>();
                // Retrieve A List of All The Student Accounts Present
                // Within the Remote Database.
                allStudentsList = manager.findAllStudents();
                
                // Check to see if Student is Already Present Within Class
                for (int i = 0; i < allStudentsList.size(); i++) {
                    // Iterate Through List of Students Already Present
                    // Within the Class.
                    for (int j = 0; j < studentsInClassList.size(); j++) {
                        // Check to See if the Current Student Identification Number
                        // Within the All Students List is the Same as the Student Identification Number
                        // Associated With the Current Student Object Entry in the Student's In Class List.
                        // If So, remove the Student Object From Both Lists. This is done to Stop the User
                        // from being able to Select A Student Already Present Within the Class.
                        if (allStudentsList.get(i).getStudentIdentificationNumber() == studentsInClassList.get(j).getStudentIdentificationNumber()) {
                            // Remove the Student Object From
                            // the All Students List.
                            allStudentsList.remove(i);
                            // Remove the Student Object From
                            // the Students in Class List.
                            studentsInClassList.remove(j);
                            // Seeing as We Are Removing
                            // the Entry, Go Back One Entry.
                            i--;
                            // Break From the Inner Loop
                            // Seeing as We Have Found A
                            // Student Present Within the Class
                            // who matches the Current All Students
                            // List Entry.
                            break;
                        }
                    }
                }
                
                // Reset the Row Data ArrayList Containing All of
                // our All Students Table Objects. This is done to
                // ensure that there are no other Entries Present
                // from a Previous Table View Process.
                rowDataListAllStudents = new ArrayList<>();
                
                // Loop Through Our Now, Non-Enrolled Student List
                // to Create A New ArrayList of CustomJTableObjectManageStudentsPanel
                // Objects. This List Will Be used to Populate the All Students
                // Table.
                for (int i = 0; i < allStudentsList.size(); i++) {
                    
                    // Get the Student's Small Profile Image FilePath String. This will be used in
                    // an ImageIcon conversion momentarily.
                    String image = "" + allStudentsList.get(i).getStudentProfileImageSmall();
                    // Retrieve the Student's Display Name which is a Combination of thier
                    // First and Last Names.
                    String name = "  " + allStudentsList.get(i).getStudentDisplayName() + "  ";
                    // Retrieve the Student's Associated Username for thier Account.
                    String username = "  " + allStudentsList.get(i).getStudentUsername() + "  ";
                    // Retrieve the Student's Email Address 
                    // associated with thier Account.
                    String email = "";
                    // Retrieve the Student's Phone Number 
                    // associated with thier Account.
                    String phone = "";
                    // Retrieve the Student's Physical Address 
                    // associated with thier Account.
                    String address = "";

                    // If the Student's Email Address Field is Empty, set the JTable Display
                    // Value to N/A (Not Available). This will also be serpated by two spaces on
                    // both sides in order to distance the width between column information in the
                    // Table. This is done to improve Application Aestheics and Table Readability.
                    if (allStudentsList.get(i).getStudentEmail().equalsIgnoreCase("")) {
                        // Assign the Not Available Value
                        // to the String.
                        email = "  N/A  ";
                    }
                    else {
                        // If the Email Address Field is not empty, assign the actual value
                        // once again seperated on both sides by two spaces.
                        email = "  " + allStudentsList.get(i).getStudentEmail() + "  ";
                    }

                    // If the Student's Phone Number Field is Empty, set the JTable Display
                    // Value to N/A (Not Available). This will also be serpated by two spaces on
                    // both sides in order to distance the width between column information in the
                    // Table. This is done to improve Application Aestheics and Table Readability.
                    if (allStudentsList.get(i).getStudentPhone().equalsIgnoreCase("") || allStudentsList.get(i).getStudentPhone().equalsIgnoreCase("Default")) {
                        // Assign the Not Available Value
                        // to the String.
                        phone = "  N/A  ";
                    }
                    else {
                        // If the Phone Number Field is not empty, assign the actual value
                        // once again seperated on both sides by two spaces.
                        phone = "  " + allStudentsList.get(i).getStudentPhone() + "  ";
                    }

                    // If the Student's Physical Address Field is Empty, set the JTable Display
                    // Value to No Address Available. This will also be serpated by two spaces on
                    // both sides in order to distance the width between column information in the
                    // Table. This is done to improve Application Aestheics and Table Readability.
                    if (allStudentsList.get(i).getStudentAddress().equalsIgnoreCase("")) {
                        // Assign the No Address Available Value
                        // to the String.
                        address = "  No Address Available  ";
                    }
                    else {
                        // If the Physical Address Field is not empty, assign the actual value
                        // once again seperated on both sides by two spaces.
                        address = "  " + allStudentsList.get(i).getStudentAddress() + "  ";
                    }

                    // Use the previously calculated Values to Form A New CustomJTableObjectManageStudentsPanel
                    // and add it to the rowDataListAllStudents ArrayList which will be used later to create
                    // All Students JTable Object.
                    rowDataListAllStudents.add(new CustomJTableObjectManageStudentsPanel(new javax.swing.ImageIcon(getClass().getResource(image)), name, allStudentsList.get(i).getStudentIdentificationNumber(), username, email, phone, address));
                }
                
                /***************************************************/

                // Execute if the All Students Class List Table
                // is Empty.
                if (rowDataListAllStudents.isEmpty()) {

                    // Create the New Table Model Using an Empty List
                    allStudentsModel = new CustomJTableModelManagementTabStudents(rowDataListAllStudents);
                    // Set the Table to show A Blank Model which will
                    // be automatically resized to fit the Container ScrollPane.
                    allStudentsTable.setModel(allStudentsModel);

                    // Disable Column Reordering so the User wont violate
                    // or change the Table's Settings.
                    allStudentsTable.getTableHeader().setReorderingAllowed(false);

                    // Show that the Default Table Model is not currently in use.
                    // This is done to Let the Program know when to show or hide
                    // components upon click.
                    defaultTableModelInUseAllStudentsList = false;

                    // In this next section of code, we will create multiple Custom Cell
                    // Renderer Objects. These Objects are responsible for changing the Overall
                    // Appearance of the Cells (Such as Background and Vertical / Horizontal Data Alignment)
                    // along with Changing things such as Data Font Type, Size, and Color. There are Two
                    // Different Types of Cell Renderers. One for the Header or "Title" Cells of A Column
                    // while the other is used to manipulate the contents of the Data Cells Contained
                    // Underneath.

                    // Create A Custom Cell Render which will be used on each of the
                    // Data Cell Rows within the Table. This Renderer will set the Font
                    // to the Regular "Lucida Grande" Font and Align the Contained text
                    // within the Center of the Cell.
                    DefaultTableCellRenderer renderer = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 0, 13));
                             // Return the Custom Cell Renderer Object
                             // which will be assigned to all Data Cells
                             // within the Table.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Black and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererBlack = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Black.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(0, 0, 0));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Royal Blue and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererRoyalBlue = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Royal Blue.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(51, 153, 255));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Set the Height of Each Row within the Table
                    // to 100 Pixels. This is done so that the Contained Data
                    // is more Seperated and thus easier to Read.
                    allStudentsTable.setRowHeight(100);

                    // Assign the Data Cell Renderer created earlier to Columns (1 - 6) Within
                    // the Table. Seeing as the First Column will contain the Student's Associated
                    // Profile Image, we will not assign a Cell Renderer to the Column. Should we
                    // Assign the cell Renderer to Column 0, a filepath to the Student's Profile Picture
                    // will be shown instead of the Actual Desired Image.

                    // Assign Data Cell Render to Column 1 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(1).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 2 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(2).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 3 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(3).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 4 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(4).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 5 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(5).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 6 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(6).setCellRenderer(renderer);

                    // Assign the Custom Cell Header Renderer Objects to each of the Columns Within
                    // the Table. We will Alternate in Assigning the Black and Royal Blue HeaderRenderer Objects
                    // by one cell each. This is done to make the Table more Aesthetically Pleasing in
                    // addition to helping with Overall Data Readability.

                    // Assign the Custom Black Header Render Object to Column 0 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(0).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 1 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(1).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 2 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(2).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 3 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(3).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 4 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(4).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 5 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(5).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 6 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(6).setHeaderRenderer(headerRendererBlack);

                    // Seeing as we are using an Empty ArrayList to Form this Table, the
                    // Width of all the Column Header Cells Combined won't be long enough to fill
                    // the entirety of the ScrollPane holding our JTable. Thus, we Assign the 
                    // AUTO_RESIZE_ALL_COLUMNS Integer to the JTable setAutoResizeMode() method.
                    // This will Automatically Resize All of the Columns withing the Table to
                    // Fill the Length of the ScrollPane. This is done for Aesthetic Improvement
                    // to the Program.
                    allStudentsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);

                    // Hide the Loading Icon in MainScreen Management Tab
                    // seeing as we have now retrieved the Student Data and
                    // used it to Create our Table.
                    main.jLabel62.setVisible(false);

                    // Hide the Table View Type Selection Components
                    // From the Users View.
                    setTableTypeSelectionComponentsVisible(false);
                    // Seeing as we now have our Table Completely made
                    // and the Loading Icon has been hidden. Renable the
                    // Table View Type Selection Components.
                    enableTableTypeSelectionComponents(true);

                    // Create an HTML Formatted Text String for the Title
                    // JLabel Located Above the Students in Class Table.
                    String formattedHtmlClassTitle = "<html><center><font color=#0093ff>" + selectedClassType.getClassTitle() + "</font> (<font color=#ff0000>All Students Not In Class</font>):</center></html>";
                    // Make the JLabel Show  the Title of the Currently
                    // Selected Class in a Royal Blue Color.
                    jLabel1.setText(formattedHtmlClassTitle);

                    // Show the All Student's Table and its Accompanying
                    // Components Seeing as the Table's Model has been Set
                    // and everything else has finished.
                    setAllStudentsListComponentsVisible(true);
                }
                // Execute if the All Students ArrayList
                // is not Empty.
                else {
                    // Once the Loop has finished Executing, Use the new rowDataListStudentsInClass ArrayList
                    // to create the Student's In Class Table Model.
                    allStudentsModel = new CustomJTableModelManagementTabStudents(rowDataListAllStudents);
                    // Set this new model to our classListTable JTable's
                    // custom model field.
                    allStudentsTable.setModel(allStudentsModel);

                    // Disable Table Column Reordering. This is done to prevent
                    // the user from Accidently altering or violating the Table's
                    // set Properties.
                    allStudentsTable.getTableHeader().setReorderingAllowed(false);

                    // Seeing as we are using a Custom Model for our Student's In
                    // Class JTable, we will set the Default Table Model Boolean
                    // Value to Zero. This is done to let Otther event Queue Threads
                    // know when to Show / Hide or Enable / Disable other Components.
                    defaultTableModelInUseAllStudentsList = false;

                    // In this next section of code, we will create multiple Custom Cell
                    // Renderer Objects. These Objects are responsible for changing the Overall
                    // Appearance of the Cells (Such as Background and Vertical / Horizontal Data Alignment)
                    // along with Changing things such as Data Font Type, Size, and Color. There are Two
                    // Different Types of Cell Renderers. One for the Header or "Title" Cells of A Column
                    // while the other is used to manipulate the contents of the Data Cells Contained
                    // Underneath.

                    // Create A Custom Cell Render which will be used on each of the
                    // Data Cell Rows within the Table. This Renderer will set the Font
                    // to the Regular "Lucida Grande" Font and Align the Contained text
                    // within the Center of the Cell.
                    DefaultTableCellRenderer renderer = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 0, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Data Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Black and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererBlack = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Black.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(0, 0, 0));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Royal Blue and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererRoyalBlue = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Royal Blue.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(51, 153, 255));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Set the Height of Each Row within the Table
                    // to 100 Pixels. This is done so that the Contained Data
                    // is more Seperated and thus easier to Read.
                    allStudentsTable.setRowHeight(100);

                    // Assign the Data Cell Renderer created earlier to Columns (1 - 6) Within
                    // the Table. Seeing as the First Column will contain the Student's Associated
                    // Profile Image, we will not assign a Cell Renderer to the Column. Should we
                    // Assign the cell Renderer to Column 0, a filepath to the Student's Profile Picture
                    // will be shown instead of the Actual Desired Image.

                    // Assign Data Cell Render to Column 1 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(1).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 2 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(2).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 3 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(3).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 4 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(4).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 5 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(5).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 6 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(6).setCellRenderer(renderer);

                    // Assign the Custom Cell Header Renderer Objects to each of the Columns Within
                    // the Table. We will Alternate in Assigning the Black and Royal Blue HeaderRenderer Objects
                    // by one cell each. This is done to make the Table more Aesthetically Pleasing in
                    // addition to helping with Overall Data Readability.

                    // Assign the Custom Black Header Render Object to Column 0 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(0).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 1 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(1).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 2 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(2).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 3 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(3).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 4 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(4).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 5 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(5).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 6 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(6).setHeaderRenderer(headerRendererBlack);

                    // Turn off Auto Resize Mode Within the Table. In the Next Step,
                    // we will Calculate the Desired Width of Each Column by mesauring
                    // the length of the longest piece of Data contained within all the
                    // rows present in the Table. We turn the Auto Resize Mode off so that
                    // the Data is all clearly show to the User.
                    allStudentsTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);

                    // Adjust Column Widths According to Largest Piece of Data Contained
                    // within one row in each column. Loop until all of the Columns have been
                    // searched through and set the Associated Width of the Longest Data Entry
                    // within thier ranks.
                    for (int column = 0; column < allStudentsTable.getColumnCount(); column++)
                    {
                        // Retrive the Table Column Model Object Associated with the Current
                        // Column Number that the loop is on.
                        TableColumn tableColumn = allStudentsTable.getColumnModel().getColumn(column);
                        // Retrieve the Prefered Width of the Column. This is the Actual Width
                        // Associated with the Column Object Within the Table.
                        int preferredWidth = tableColumn.getMinWidth();
                        // Retrieve the Max Width of the Column. This is the Width which the
                        // column may be stretched too should it be required.
                        int maxWidth = tableColumn.getMaxWidth();

                        // Loop through each of the Rows Within the Current Column
                        for (int row = 0; row < allStudentsTable.getRowCount(); row++)
                        {
                            // Retrieve the Cell Renderer Object Associated With the Current
                            // Column and Row Number. This will be used to retrieve the size
                            // information of the Data Contained within the Cell.
                            TableCellRenderer cellRenderer = allStudentsTable.getCellRenderer(row, column);
                            // Convert the Cell Renderer into a Generic Component Object to Retrieve
                            // the Data Size Information.
                            Component c = allStudentsTable.prepareRenderer(cellRenderer, row, column);
                            // Retrieve the Prefered Width of the Components Containing the Data.
                            // The Prefered Width is the current width of the Compononet after all of the
                            // changes we invoked earlier. We then combine this with the Intercell Spacing
                            // Width to get the Length in Pixels of the Data.
                            int width = c.getPreferredSize().width + allStudentsTable.getIntercellSpacing().width;
                            // Get the Maximum Size that the Cell's Width Can Become.
                            preferredWidth = Math.max(preferredWidth, width);

                            // Check to see if the Preferered Width is greater than the
                            // Cells Maximum Visible Dimension Size. If so,
                            // We've exceeded the maximum width, so theres
                            // no need to check other rows.
                            if (preferredWidth >= maxWidth)
                            {
                                // Set the Prefered Width to the Max
                                // Width's Size.
                                preferredWidth = maxWidth;
                                // Break Inner Loop.
                                break;
                            }
                        }

                        // Set the Prefererd Width of the Current Column to
                        // the Maximum Width Required to Fully Display the
                        // longest piece of information.
                        tableColumn.setPreferredWidth(preferredWidth);
                    }

                    // Seeing as We have made changes to the Original Structure
                    // of the JScrollPane Viewport, revalidate the object before repainting
                    // it to the Screen.
                    allStudentsTableScrollPane.revalidate();
                    allStudentsTableScrollPane.repaint();

                    // Seeing as We have made changes to the Original Structure
                    // of the JTable, revalidate the object before repainting
                    // it to the Screen.
                    allStudentsTable.revalidate();
                    allStudentsTable.repaint();

                    // Create Integer Array Variable to Hold the Individual Width's
                    // of each Column now that the resizing operations have been
                    // performed.
                    int[] columnWidths = {0, 0, 0, 0, 0, 0, 0};

                    // Get the Current Width of the First Column.
                    columnWidths[0] = allStudentsTable.getColumnModel().getColumn(0).getPreferredWidth();
                    // Get the Current Width of the Second Column.
                    columnWidths[1] = allStudentsTable.getColumnModel().getColumn(1).getPreferredWidth();
                    // Get the Current Width of the Third Column.
                    columnWidths[2] = allStudentsTable.getColumnModel().getColumn(2).getPreferredWidth();
                    // Get the Current Width of the Forth Column.
                    columnWidths[3] = allStudentsTable.getColumnModel().getColumn(3).getPreferredWidth();
                    // Get the Current Width of the Fifth Column.
                    columnWidths[4] = allStudentsTable.getColumnModel().getColumn(4).getPreferredWidth();
                    // Get the Current Width of the Sixth Column.
                    columnWidths[5] = allStudentsTable.getColumnModel().getColumn(5).getPreferredWidth();
                    // Get the Current Width of the Seventh Column.
                    columnWidths[6] = allStudentsTable.getColumnModel().getColumn(6).getPreferredWidth();

                    // Combine All of the Column Widths to get A Total
                    // Width in pixels. This is done to provide a comparison
                    // value in the next step.
                    int jTableWidth = columnWidths[0] + columnWidths[1] + columnWidths[2] + columnWidths[3] + columnWidths[4] + columnWidths[5] + columnWidths[6];

                    // If The Width of All the Current Columns in the JTable is
                    // Less than the Size of the JScrollPane's Visible Viewport Width, then
                    // resize the Last Column to Fit the Entire ScrollPane Width
                    if (jTableWidth < 754) {
                        // Set JTable Resize Mode to Automatically Resize the Last Column
                        // should the current assortment of the Datat contained within all of
                        // the columns and rows is less in pixel width than the visible
                        // Area of the Container JViewPort.
                        allStudentsTable.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
                    }

                    // Hide the Loading Icon in MainScreen Management Tab
                    // seeing as we have now retrieved the Student Data and
                    // used it to Create our Table.
                    main.jLabel62.setVisible(false);

                    // Hide the Table View Type Selection Components
                    // From the Users View.
                    setTableTypeSelectionComponentsVisible(false);
                    // Seeing as we now have our Table Completely made
                    // and the Loading Icon has been hidden. Renable the
                    // Table View Type Selection Components.
                    enableTableTypeSelectionComponents(true);

                    // Create an HTML Formatted Text String for the Title
                    // JLabel Located Above the Students in Class Table.
                    String formattedHtmlClassTitle = "<html><center><font color=#0093ff>" + selectedClassType.getClassTitle() + "</font> (<font color=#ff0000>All Students Not In Class</font>):</center></html>";
                    // Make the JLabel Show  the Title of the Currently
                    // Selected Class in a Royal Blue Color.
                    jLabel1.setText(formattedHtmlClassTitle);

                    // Show the All Student's Table and its Accompanying
                    // Components Seeing as the Table's Model has been Set
                    // and everything else has finished.
                    setAllStudentsListComponentsVisible(true);
                }
            }
            // A Thread that Waits for the User to choose
            // a decision in the Remove Student Confirmation
            // Window.
            else if (task == 3) {

                // Reset the Response User's Response Value in Case it Is Currently
                // Stuck At 3.
                messageResponseTracker.setRemoveStudentResponseValue(0);
                
                boolean breaker = false;
                    
                while (breaker == false) {
                    // If the User Clicks Yes.
                    switch (messageResponseTracker.getRemoveStudentResponseValue()) {
                        case 1:
                            System.out.println("Getting Here in The Remove Student Thread. 1");
                            // Reset the Synchronized Response Value
                            messageResponseTracker.setRemoveStudentResponseValue(0);
                            
                            // Seeing as the User has Confirmed that they want to
                            // Remove the Selected Student From the Database, Call the
                            // Removal Method to Remove the Student And Any Associated
                            // Attendance Records From the Database.
                            DatabaseOperationResult operationResult = manager.removeStudentFromClass(selectedClassType.getClassID(), selectedStudentInClass.getStudentIdentificationNumber(), lastStudent);
            
                            System.out.println("Getting Here in The Remove Student Thread. 2");
                            // If the Overall Result of the Database Operation
                            // Sequence is a Failure.
                            if (operationResult.getResult() == false) {
                                System.out.println("Getting Here in The Remove Student Thread. 3");
                                // Create And Show Error Message Telling the User that
                                // A SQL Exception Has Occured While Attempting to
                                // remove the Selected Student from the Current Class.
                                if (operationResult.getType().equalsIgnoreCase("SQL Exception")) {
                                    // Hide the Loading Gif Image to
                                    // show the User that the Background Operation
                                    // has finished Executing.
                                    main.jLabel62.setVisible(false);
                                    // Re-Enable the Components Associated
                                    // With the Students In Class Table Seeing
                                    // As the Operation Has Finished.
                                    enableStudentsInClassTableComponents(true);
                                    
                                    // Create New Instance of the WarningMessageManageStudentsAddStudent Warning Window.
                                    WarningMessageManageStudentsAddStudent warning = new WarningMessageManageStudentsAddStudent(1);
                                    // Create HTML Formatted Text that will be displayed in the Warning Message Window.
                                    String formattedHTML = "<html><center>And Error Has Occured While Attempting To Add the Student to the Class Please Try Again Later.</center></html>";
                                    
                                    // Set the Icon of the new Warning Message Window As the Warning Icon.
                                    warning.jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/mothershipattendance/Image/warningemblemscaled.png")));
                                    // Set the Warning Message JLabel to Display the HTML Text.
                                    warning.jLabel6.setText(formattedHTML);
                                    
                                    // Make the Warning Message Window Visible.
                                    warning.setVisible(true);
                                }
                                // Create And Show Error Message Telling the User that
                                // A Communication's Exception Has Occured While Attempting to
                                // remove the Selected Student from the Current Class.
                                else if (operationResult.getType().equalsIgnoreCase("Communications Exception")) {
                                    System.out.println("Getting Here in The Remove Student Thread. 4");
                                    // Hide the Loading Gif Image to
                                    // show the User that the Background Operation
                                    // has finished Executing.
                                    main.jLabel62.setVisible(false);
                                    // Re-Enable the Components Associated
                                    // With the Students In Class Table Seeing
                                    // As the Operation Has Finished.
                                    enableStudentsInClassTableComponents(true);
                                    
                                    // Create New Internet Connection Failure Class
                                    WarningMessageInternetConnectionFailure warning = new WarningMessageInternetConnectionFailure("Management Tab Add Student Window");
                                    
                                    // Make Warning Message Window Visible.
                                    warning.setVisible(true);
                                }
                            }
                            // If the Overall Result of the Database Operation
                            // Sequence is Successful.
                            else {
                                System.out.println("Getting Here in The Remove Student Thread. 5");
                                // Hide the Loading Gif Image to
                                // show the User that the Background Operation
                                // has finished Executing.
                                main.jLabel62.setVisible(false);
                                // Re-Enable the Components Associated
                                // With the Students In Class Table Seeing
                                // As the Operation Has Finished.
                                enableStudentsInClassTableComponents(true);

                                // Create New Instance of the Successful Status Message Class To Let
                                // User Know that the Student Was Successfully Removed From the Class.
                                StatusMessageStudentModificationSuccessful smssa = new StatusMessageStudentModificationSuccessful(2);

                                // Create Formatted HTML Text That Tells the User The Details of the Successful Operation.
                                String formattedHTML = "<html><center>Student <font color=#00d7ed>" + selectedStudentInClass.getStudentDisplayName() + "</font> has been successfully removed from the Class <font color=#01ed00>" + selectedClassType.getClassTitle() + "</font>.</center></html>";
                                // Set the Success Message Window's Display Text.
                                smssa.jLabel6.setText(formattedHTML);

                                // Show Success Status Message
                                // Window
                                smssa.setVisible(true);

                                // Repopulate And Repaint the Student's
                                // In Class Table in MainScreen Manage
                                // Students Panel.
                                TaskHandler handler = new TaskHandler(5);
                                // Execute Thread.
                                handler.execute();
                            }
                            
                            // Break From the Loop And End the Thread
                            // Seeing As the User Has Choosen to Cancel
                            // the Operation or Say No.
                            breaker = true;
                        case 2:
                            System.out.println("Getting Here in The Remove Student Thread. 6");
                            // Reset the Synchronized Response Value
                            messageResponseTracker.setRemoveStudentResponseValue(0);
                            // Re-Enable the Components Associated With
                            // the Students In Class Table.
                            enableStudentsInClassTableComponents(true);
                            // Hide the Loader Symbol Seeing As the User
                            // has Chosen to Cancel the Remove Student Operation.
                            main.jLabel62.setVisible(false);
                            // Break From the Loop And End the Thread
                            // Seeing As the User Has Choosen to Cancel
                            // the Operation or Say No.
                            breaker = true;
                        case 3:
                            System.out.println("Getting Here in The Remove Student Thread. 7");
                            // Reset the Synchronized Response Value
                            messageResponseTracker.setRemoveStudentResponseValue(0);
                            // Re-Enable the Components Associated With
                            // the Students In Class Table.
                            enableStudentsInClassTableComponents(true);
                            // Hide the Loader Symbol Seeing As the User
                            // has Chosen to Cancel the Add Student Operation.
                            main.jLabel62.setVisible(false);
                            // Break From the Loop And End the Thread
                            // Seeing As the User Has Choosen to Cancel
                            // the Operation or Say No.
                            breaker = true;
                        default:
                            // Do Nothing
                    }
                }
            }
            // Reset Students In Class Table Contents After
            // Student Addition or Removal is
            // Performed.
            else if (task == 4) {

                try {
                    // Get a List of the Current Students within the Class
                    studentsInClassList = manager.getStudentsAssociatedWithClass(selectedClassType.getClassID());
                    // Reset Students in Class Table ArrayList.
                    rowDataListStudentsInClass = new ArrayList<CustomJTableObjectManageStudentsPanel>();

                    // Execute if the Currently Selected Class Has No
                    // Students within its Class Roster
                    if (studentsInClassList.isEmpty()) {

                        // Create the New Table Model Using an Empty List
                        studentsInClassModel = new CustomJTableModelManagementTabStudents(rowDataListStudentsInClass);
                        // Set the Table to show A Blank Model which will
                        // be automatically resized to fit the Container ScrollPane.
                        classListTable.setModel(studentsInClassModel);

                        // Disable Column Reordering so the User wont violate
                        // or change the Table's Settings.
                        classListTable.getTableHeader().setReorderingAllowed(false);

                        // Show that the Default Table Model is not currently in use.
                        // This is done to Let the Program know when to show or hide
                        // components upon click.
                        defaultTableModelInUseStudentsInClassList = false;

                        // In this next section of code, we will create multiple Custom Cell
                        // Renderer Objects. These Objects are responsible for changing the Overall
                        // Appearance of the Cells (Such as Background and Vertical / Horizontal Data Alignment)
                        // along with Changing things such as Data Font Type, Size, and Color. There are Two
                        // Different Types of Cell Renderers. One for the Header or "Title" Cells of A Column
                        // while the other is used to manipulate the contents of the Data Cells Contained
                        // Underneath.

                        // Create A Custom Cell Render which will be used on each of the
                        // Data Cell Rows within the Table. This Renderer will set the Font
                        // to the Regular "Lucida Grande" Font and Align the Contained text
                        // within the Center of the Cell.
                        DefaultTableCellRenderer renderer = new DefaultTableCellRenderer(){
                            @Override
                            public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                                 Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                                 // Create Integer Variable that holds the Dimension Location
                                 // of the Center of the Cell.
                                 int align = DefaultTableCellRenderer.CENTER;
                                 // Assign the Center Location to the Cells Data Positioning Method.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                                 // Assign a Font to the Data Contained Within the Cell.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 0, 13));
                                 // Return the Custom Cell Renderer Object
                                 // which will be assigned to all Data Cells
                                 // within the Table.
                                 return tableCellRendererComponent;
                            }
                        };

                        // Create A Custom Column Header Renderer. This Will be used to both
                        // Center and Change the Accompanying Font / Background of the Chosen
                        // Column Title Cell. This Particular Renderer is responsible for Changing
                        // the Column Cells Background Color to Black and its Font Color to White.
                        // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                        // Horizontally Center the Column Title Within the Cell.
                        DefaultTableCellRenderer headerRendererBlack = new DefaultTableCellRenderer(){
                            @Override
                            public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                                 Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                                 // Create Integer Variable that holds the Dimension Location
                                 // of the Center of the Cell.
                                 int align = DefaultTableCellRenderer.CENTER;
                                 // Assign the Center Location to the Cells Data Positioning Method.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                                 // Set the Background Color of the Cell to Black.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(0, 0, 0));
                                 // Set the Font Color of the Data Within the Cell to White
                                 // in order to Contrast the Background.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                                 // Assign a Font to the Data Contained Within the Cell.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                                 // Return the Custom Cell Renderer Object
                                 // which Can be Assigned to a Header Column Cell.
                                 return tableCellRendererComponent;
                            }
                        };

                        // Create A Custom Column Header Renderer. This Will be used to both
                        // Center and Change the Accompanying Font / Background of the Chosen
                        // Column Title Cell. This Particular Renderer is responsible for Changing
                        // the Column Cells Background Color to Royal Blue and its Font Color to White.
                        // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                        // Horizontally Center the Column Title Within the Cell.
                        DefaultTableCellRenderer headerRendererRoyalBlue = new DefaultTableCellRenderer(){
                            @Override
                            public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                                 Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                                 // Create Integer Variable that holds the Dimension Location
                                 // of the Center of the Cell.
                                 int align = DefaultTableCellRenderer.CENTER;
                                 // Assign the Center Location to the Cells Data Positioning Method.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                                 // Set the Background Color of the Cell to Royal Blue.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(51, 153, 255));
                                 // Set the Font Color of the Data Within the Cell to White
                                 // in order to Contrast the Background.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                                 // Assign a Font to the Data Contained Within the Cell.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                                 // Return the Custom Cell Renderer Object
                                 // which Can be Assigned to a Header Column Cell.
                                 return tableCellRendererComponent;
                            }
                        };

                        // Set the Height of Each Row within the Table
                        // to 100 Pixels. This is done so that the Contained Data
                        // is more Seperated and thus easier to Read.
                        classListTable.setRowHeight(100);

                        // Assign the Data Cell Renderer created earlier to Columns (1 - 6) Within
                        // the Table. Seeing as the First Column will contain the Student's Associated
                        // Profile Image, we will not assign a Cell Renderer to the Column. Should we
                        // Assign the cell Renderer to Column 0, a filepath to the Student's Profile Picture
                        // will be shown instead of the Actual Desired Image.

                        // Assign Data Cell Render to Column 1 Within the Table.
                        classListTable.getColumnModel().getColumn(1).setCellRenderer(renderer);
                        // Assign Data Cell Render to Column 2 Within the Table.
                        classListTable.getColumnModel().getColumn(2).setCellRenderer(renderer);
                        // Assign Data Cell Render to Column 3 Within the Table.
                        classListTable.getColumnModel().getColumn(3).setCellRenderer(renderer);
                        // Assign Data Cell Render to Column 4 Within the Table.
                        classListTable.getColumnModel().getColumn(4).setCellRenderer(renderer);
                        // Assign Data Cell Render to Column 5 Within the Table.
                        classListTable.getColumnModel().getColumn(5).setCellRenderer(renderer);
                        // Assign Data Cell Render to Column 6 Within the Table.
                        classListTable.getColumnModel().getColumn(6).setCellRenderer(renderer);

                        // Assign the Custom Cell Header Renderer Objects to each of the Columns Within
                        // the Table. We will Alternate in Assigning the Black and Royal Blue HeaderRenderer Objects
                        // by one cell each. This is done to make the Table more Aesthetically Pleasing in
                        // addition to helping with Overall Data Readability.

                        // Assign the Custom Black Header Render Object to Column 0 Within the Table.
                        classListTable.getColumnModel().getColumn(0).setHeaderRenderer(headerRendererBlack);
                        // Assign the Custom Royal Blue Header Render Object to Column 1 Within the Table.
                        classListTable.getColumnModel().getColumn(1).setHeaderRenderer(headerRendererRoyalBlue);
                        // Assign the Custom Black Header Render Object to Column 2 Within the Table.
                        classListTable.getColumnModel().getColumn(2).setHeaderRenderer(headerRendererBlack);
                        // Assign the Custom Royal Blue Header Render Object to Column 3 Within the Table.
                        classListTable.getColumnModel().getColumn(3).setHeaderRenderer(headerRendererRoyalBlue);
                        // Assign the Custom Black Header Render Object to Column 4 Within the Table.
                        classListTable.getColumnModel().getColumn(4).setHeaderRenderer(headerRendererBlack);
                        // Assign the Custom Royal Blue Header Render Object to Column 5 Within the Table.
                        classListTable.getColumnModel().getColumn(5).setHeaderRenderer(headerRendererRoyalBlue);
                        // Assign the Custom Black Header Render Object to Column 6 Within the Table.
                        classListTable.getColumnModel().getColumn(6).setHeaderRenderer(headerRendererBlack);

                        // Seeing as we are using an Empty ArrayList to Form this Table, the
                        // Width of all the Column Header Cells Combined won't be long enough to fill
                        // the entirety of the ScrollPane holding our JTable. Thus, we Assign the 
                        // AUTO_RESIZE_ALL_COLUMNS Integer to the JTable setAutoResizeMode() method.
                        // This will Automatically Resize All of the Columns withing the Table to
                        // Fill the Length of the ScrollPane. This is done for Aesthetic Improvement
                        // to the Program.
                        classListTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);

                        // Hide the Loading Icon in MainScreen Management Tab
                        // seeing as we have now retrieved the Student Data and
                        // used it to Create our Table.
                        main.jLabel62.setVisible(false);

                        // Hide the Table View Type Selection Components
                        // From the Users View.
                        setTableTypeSelectionComponentsVisible(false);
                        // Ensure that the Remove Student From Class
                        // Button is not visible once the Table is shown.
                        // This Button should only appear when the Instructor
                        // clicks upon a Student within the Students in Class
                        // Table.
                        setRemoveStudentFromClassButtonVisible(false);
                        // Seeing as we now have our Table Completely made
                        // and the Loading Icon has been hidden. Renable the
                        // Table View Type Selection Components.
                        enableTableTypeSelectionComponents(true);

                        // Create an HTML Formatted Text String for the Title
                        // JLabel Located Above the Students in Class Table.
                        String formattedHtmlClassTitle = "<html><center><font color=#0093ff>" + selectedClassType.getClassTitle() + "</font> Student List:</center></html>";
                        // Make the JLabel Show  the Title of the Currently
                        // Selected Class in a Royal Blue Color.
                        jLabel1.setText(formattedHtmlClassTitle);

                        // Show the Students in Class Table and its Accompanying
                        // Components Seeing as the Table's Model has been Set
                        // and everything else has finished.
                        setClassStudentListComponentsVisible(true);
                    }
                    // Execute if the Currently Selected Class Already
                    // has Students Present within its Roster.
                    else {

                        // The CustomJTableModelManagementTabStudents JTable Object Requires
                        // An ArrayList or List Object to be Passed in as its Parameter. However
                        // This List Object must in turn contain Custom Objects which will be
                        // Automatically used to Display the Data Within the Table. Thus, in this
                        // for loop, we convert the Student ArrayList retrived from the Remote
                        // Database into a new ArrayList of CustomJTableObjectManageStudentsPanel Objects,
                        // each of which contains a variable holding the desired Data Type that corresponds
                        // to the Column Locations Within the Table.
                        for (int i = 0; i < studentsInClassList.size(); i++) {

                            // Get the Student's Small Profile Image FilePath String. This will be used in
                            // an ImageIcon conversion momentarily.
                            String image = "" + studentsInClassList.get(i).getStudentProfileImageSmall();
                            // Retrieve the Student's Display Name which is a Combination of thier
                            // First and Last Names.
                            String name = "  " + studentsInClassList.get(i).getStudentDisplayName() + "  ";
                            // Retrieve the Student's Associated Username for thier Account.
                            String username = "  " + studentsInClassList.get(i).getStudentUsername() + "  ";
                            // Retrieve the Student's Email Address 
                            // associated with thier Account.
                            String email = "";
                            // Retrieve the Student's Phone Number 
                            // associated with thier Account.
                            String phone = "";
                            // Retrieve the Student's Physical Address 
                            // associated with thier Account.
                            String address = "";

                            // If the Student's Email Address Field is Empty, set the JTable Display
                            // Value to N/A (Not Available). This will also be serpated by two spaces on
                            // both sides in order to distance the width between column information in the
                            // Table. This is done to improve Application Aestheics and Table Readability.
                            if (studentsInClassList.get(i).getStudentEmail().equalsIgnoreCase("")) {
                                // Assign the Not Available Value
                                // to the String.
                                email = "  N/A  ";
                            }
                            else {
                                // If the Email Address Field is not empty, assign the actual value
                                // once again seperated on both sides by two spaces.
                                email = "  " + studentsInClassList.get(i).getStudentEmail() + "  ";
                            }

                            // If the Student's Phone Number Field is Empty, set the JTable Display
                            // Value to N/A (Not Available). This will also be serpated by two spaces on
                            // both sides in order to distance the width between column information in the
                            // Table. This is done to improve Application Aestheics and Table Readability.
                            if (studentsInClassList.get(i).getStudentPhone().equalsIgnoreCase("") || studentsInClassList.get(i).getStudentPhone().equalsIgnoreCase("Default")) {
                                // Assign the Not Available Value
                                // to the String.
                                phone = "  N/A  ";
                            }
                            else {
                                // If the Phone Number Field is not empty, assign the actual value
                                // once again seperated on both sides by two spaces.
                                phone = "  " + studentsInClassList.get(i).getStudentPhone() + "  ";
                            }

                            // If the Student's Physical Address Field is Empty, set the JTable Display
                            // Value to No Address Available. This will also be serpated by two spaces on
                            // both sides in order to distance the width between column information in the
                            // Table. This is done to improve Application Aestheics and Table Readability.
                            if (studentsInClassList.get(i).getStudentAddress().equalsIgnoreCase("")) {
                                // Assign the No Address Available Value
                                // to the String.
                                address = "  No Address Available  ";
                            }
                            else {
                                // If the Physical Address Field is not empty, assign the actual value
                                // once again seperated on both sides by two spaces.
                                address = "  " + studentsInClassList.get(i).getStudentAddress() + "  ";
                            }

                            // Use the previously calculated Values to Form A New CustomJTableObjectManageStudentsPanel
                            // and add it to the rowDataListStudentsInClass ArrayList which will be used later to create
                            // Student's In Class JTable Object.
                            rowDataListStudentsInClass.add(new CustomJTableObjectManageStudentsPanel(new javax.swing.ImageIcon(getClass().getResource(image)), name, studentsInClassList.get(i).getStudentIdentificationNumber(), username, email, phone, address));
                        }

                        // Once the Loop has finished Executing, Use the new rowDataListStudentsInClass ArrayList
                        // to create the Student's In Class Table Model.
                        studentsInClassModel = new CustomJTableModelManagementTabStudents(rowDataListStudentsInClass);
                        // Set this new model to our classListTable JTable's
                        // custom model field.
                        classListTable.setModel(studentsInClassModel);

                        // Disable Table Column Reordering. This is done to prevent
                        // the user from Accidently altering or violating the Table's
                        // set Properties.
                        classListTable.getTableHeader().setReorderingAllowed(false);

                        // Seeing as we are using a Custom Model for our Student's In
                        // Class JTable, we will set the Default Table Model Boolean
                        // Value to Zero. This is done to let other event Queue Threads
                        // know when to Show / Hide or Enable / Disable other Components.
                        defaultTableModelInUseStudentsInClassList = false;


                        // In this next section of code, we will create multiple Custom Cell
                        // Renderer Objects. These Objects are responsible for changing the Overall
                        // Appearance of the Cells (Such as Background and Vertical / Horizontal Data Alignment)
                        // along with Changing things such as Data Font Type, Size, and Color. There are Two
                        // Different Types of Cell Renderers. One for the Header or "Title" Cells of A Column
                        // while the other is used to manipulate the contents of the Data Cells Contained
                        // Underneath.

                        // Create A Custom Cell Render which will be used on each of the
                        // Data Cell Rows within the Table. This Renderer will set the Font
                        // to the Regular "Lucida Grande" Font and Align the Contained text
                        // within the Center of the Cell.
                        DefaultTableCellRenderer renderer = new DefaultTableCellRenderer(){
                            @Override
                            public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                                 Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                                 // Create Integer Variable that holds the Dimension Location
                                 // of the Center of the Cell.
                                 int align = DefaultTableCellRenderer.CENTER;
                                 // Assign the Center Location to the Cells Data Positioning Method.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                                 // Assign a Font to the Data Contained Within the Cell.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 0, 13));
                                 // Return the Custom Cell Renderer Object
                                 // which Can be Assigned to a Data Cell.
                                 return tableCellRendererComponent;
                            }
                        };

                        // Create A Custom Column Header Renderer. This Will be used to both
                        // Center and Change the Accompanying Font / Background of the Chosen
                        // Column Title Cell. This Particular Renderer is responsible for Changing
                        // the Column Cells Background Color to Black and its Font Color to White.
                        // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                        // Horizontally Center the Column Title Within the Cell.
                        DefaultTableCellRenderer headerRendererBlack = new DefaultTableCellRenderer(){
                            @Override
                            public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                                 Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                                 // Create Integer Variable that holds the Dimension Location
                                 // of the Center of the Cell.
                                 int align = DefaultTableCellRenderer.CENTER;
                                 // Assign the Center Location to the Cells Data Positioning Method.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                                 // Set the Background Color of the Cell to Black.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(0, 0, 0));
                                 // Set the Font Color of the Data Within the Cell to White
                                 // in order to Contrast the Background.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                                 // Assign a Font to the Data Contained Within the Cell.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                                 // Return the Custom Cell Renderer Object
                                 // which Can be Assigned to a Header Column Cell.
                                 return tableCellRendererComponent;
                            }
                        };

                        // Create A Custom Column Header Renderer. This Will be used to both
                        // Center and Change the Accompanying Font / Background of the Chosen
                        // Column Title Cell. This Particular Renderer is responsible for Changing
                        // the Column Cells Background Color to Royal Blue and its Font Color to White.
                        // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                        // Horizontally Center the Column Title Within the Cell.
                        DefaultTableCellRenderer headerRendererRoyalBlue = new DefaultTableCellRenderer(){
                            @Override
                            public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                                 Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                                 // Create Integer Variable that holds the Dimension Location
                                 // of the Center of the Cell.
                                 int align = DefaultTableCellRenderer.CENTER;
                                 // Assign the Center Location to the Cells Data Positioning Method.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                                 // Set the Background Color of the Cell to Royal Blue.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(51, 153, 255));
                                 // Set the Font Color of the Data Within the Cell to White
                                 // in order to Contrast the Background.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                                 // Assign a Font to the Data Contained Within the Cell.
                                 ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                                 // Return the Custom Cell Renderer Object
                                 // which Can be Assigned to a Header Column Cell.
                                 return tableCellRendererComponent;
                            }
                        };

                        // Set the Height of Each Row within the Table
                        // to 100 Pixels. This is done so that the Contained Data
                        // is more Seperated and thus easier to Read.
                        classListTable.setRowHeight(100);

                        // Assign the Data Cell Renderer created earlier to Columns (1 - 6) Within
                        // the Table. Seeing as the First Column will contain the Student's Associated
                        // Profile Image, we will not assign a Cell Renderer to the Column. Should we
                        // Assign the cell Renderer to Column 0, a filepath to the Student's Profile Picture
                        // will be shown instead of the Actual Desired Image.

                        // Assign Data Cell Render to Column 1 Within the Table.
                        classListTable.getColumnModel().getColumn(1).setCellRenderer(renderer);
                        // Assign Data Cell Render to Column 2 Within the Table.
                        classListTable.getColumnModel().getColumn(2).setCellRenderer(renderer);
                        // Assign Data Cell Render to Column 3 Within the Table.
                        classListTable.getColumnModel().getColumn(3).setCellRenderer(renderer);
                        // Assign Data Cell Render to Column 4 Within the Table.
                        classListTable.getColumnModel().getColumn(4).setCellRenderer(renderer);
                        // Assign Data Cell Render to Column 5 Within the Table.
                        classListTable.getColumnModel().getColumn(5).setCellRenderer(renderer);
                        // Assign Data Cell Render to Column 6 Within the Table.
                        classListTable.getColumnModel().getColumn(6).setCellRenderer(renderer);

                        // Assign the Custom Cell Header Renderer Objects to each of the Columns Within
                        // the Table. We will Alternate in Assigning the Black and Royal Blue HeaderRenderer Objects
                        // by one cell each. This is done to make the Table more Aesthetically Pleasing in
                        // addition to helping with Overall Data Readability.

                        // Assign the Custom Black Header Render Object to Column 0 Within the Table.
                        classListTable.getColumnModel().getColumn(0).setHeaderRenderer(headerRendererBlack);
                        // Assign the Custom Royal Blue Header Render Object to Column 1 Within the Table.
                        classListTable.getColumnModel().getColumn(1).setHeaderRenderer(headerRendererRoyalBlue);
                        // Assign the Custom Black Header Render Object to Column 2 Within the Table.
                        classListTable.getColumnModel().getColumn(2).setHeaderRenderer(headerRendererBlack);
                        // Assign the Custom Royal Blue Header Render Object to Column 3 Within the Table.
                        classListTable.getColumnModel().getColumn(3).setHeaderRenderer(headerRendererRoyalBlue);
                        // Assign the Custom Black Header Render Object to Column 4 Within the Table.
                        classListTable.getColumnModel().getColumn(4).setHeaderRenderer(headerRendererBlack);
                        // Assign the Custom Royal Blue Header Render Object to Column 5 Within the Table.
                        classListTable.getColumnModel().getColumn(5).setHeaderRenderer(headerRendererRoyalBlue);
                        // Assign the Custom Black Header Render Object to Column 6 Within the Table.
                        classListTable.getColumnModel().getColumn(6).setHeaderRenderer(headerRendererBlack);

                        // Turn off Auto Resize Mode Within the Table. In the Next Step,
                        // we will Calculate the Desired Width of Each Column by mesauring
                        // the length of the longest piece of Data contained within all the
                        // rows present in the Table. We turn the Auto Resize Mode off so that
                        // the Data is all clearly show to the User.
                        classListTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);

                        // Adjust Column Widths According to Largest Piece of Data Contained
                        // within one rows in each column. Loop until all of the Columns have been
                        // searched through and set the Associated Width of the Longest Data Entry
                        // within thier ranks.
                        for (int column = 0; column < classListTable.getColumnCount(); column++)
                        {
                            // Retrive the Table Column Model Object Associated with the Current
                            // Column Number that the loop is on.
                            TableColumn tableColumn = classListTable.getColumnModel().getColumn(column);
                            // Retrieve the Prefered Width of the Column. This is the Actual Width
                            // Associated with the Column Object Within the Table.
                            int preferredWidth = tableColumn.getMinWidth();
                            // Retrieve the Max Width of the Column. This is the Width which the
                            // column may be stretched too should it be required.
                            int maxWidth = tableColumn.getMaxWidth();

                            // Loop through each of the Rows Within the Current Column
                            for (int row = 0; row < classListTable.getRowCount(); row++)
                            {
                                // Retrieve the Cell Renderer Object Associated With the Current
                                // Column and Row Number. This will be used to retrieve the size
                                // information of the Data Contained within the Cell.
                                TableCellRenderer cellRenderer = classListTable.getCellRenderer(row, column);
                                // Convert the Cell Renderer into a Generic Component Object to Retrieve
                                // the Data Size Information.
                                Component c = classListTable.prepareRenderer(cellRenderer, row, column);
                                // Retrieve the Prefered Width of the Components Containing the Data.
                                // The Prefered Width is the current width of the Compononet after all of the
                                // changes we invoked earlier. We then combine this with the Intercell Spacing
                                // Width to get the Length in Pixels of the Data.
                                int width = c.getPreferredSize().width + classListTable.getIntercellSpacing().width;
                                // Get the Maximum Size that the Cell's Width Can Become.
                                preferredWidth = Math.max(preferredWidth, width);

                                // Check to see if the Preferered Width is greater than the
                                // Cells Maximum Visible Dimension Size. If so,
                                // We've exceeded the maximum width, so theres
                                // no need to check other rows.
                                if (preferredWidth >= maxWidth)
                                {
                                    // Set the Prefered Width to the Max
                                    // Width's Size.
                                    preferredWidth = maxWidth;
                                    // Break Inner Loop.
                                    break;
                                }
                            }

                            // Se the Prefererd Width of the Current Column to
                            // the Maximum Width Required to Fully Display the
                            // longest piece of information.
                            tableColumn.setPreferredWidth(preferredWidth);
                        }

                        // Seeing as We have made changes to the Original Structure
                        // of the JScrollPane Viewport, revalidate the object before repainting
                        // it to the Screen.
                        classListTableScrollPane.revalidate();
                        classListTableScrollPane.repaint();

                        // Seeing as We have made changes to the Original Structure
                        // of the JTable, revalidate the object before repainting
                        // it to the Screen.
                        classListTable.revalidate();
                        classListTable.repaint();

                        // Create Integer Array Variable to Hold the Individual Width's
                        // of each Column now that the resizing operations have been
                        // performed.
                        int[] columnWidths = {0, 0, 0, 0, 0, 0, 0};

                        // Get the Current Width of the First Column.
                        columnWidths[0] = classListTable.getColumnModel().getColumn(0).getPreferredWidth();
                        // Get the Current Width of the Second Column.
                        columnWidths[1] = classListTable.getColumnModel().getColumn(1).getPreferredWidth();
                        // Get the Current Width of the Third Column.
                        columnWidths[2] = classListTable.getColumnModel().getColumn(2).getPreferredWidth();
                        // Get the Current Width of the Forth Column.
                        columnWidths[3] = classListTable.getColumnModel().getColumn(3).getPreferredWidth();
                        // Get the Current Width of the Fifth Column.
                        columnWidths[4] = classListTable.getColumnModel().getColumn(4).getPreferredWidth();
                        // Get the Current Width of the Sixth Column.
                        columnWidths[5] = classListTable.getColumnModel().getColumn(5).getPreferredWidth();
                        // Get the Current Width of the Seventh Column.
                        columnWidths[6] = classListTable.getColumnModel().getColumn(6).getPreferredWidth();

                        // Combine All of the Column Widths to get A Total
                        // Width in pixels. This is done to provide a comparison
                        // value in the next step.
                        int jTableWidth = columnWidths[0] + columnWidths[1] + columnWidths[2] + columnWidths[3] + columnWidths[4] + columnWidths[5] + columnWidths[6];

                        // If The Width of All the Current Columns in the JTable is
                        // Less than the Size of the JScrollPane's Visible Viewport Width, then
                        // resize the Last Column to Fit the Entire ScrollPane Width
                        if (jTableWidth < 754) {
                            // Set JTable Resize Mode to Automatically Resize the Last Column
                            // should the current assortment of the Datat contained within all of
                            // the columns and rows is less in pixel width than the visible
                            // Area of the Container JViewPort.
                            classListTable.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
                        }
                    }

                    // Show Loading Icon in MainScreen Management Tab
                    main.jLabel62.setVisible(false);

                    // Show the Students in Class Table and its Accompanying
                    // Components Seeing as the Table's Model has been Set
                    // and everything else has finished.
                    setClassStudentListComponentsVisible(true);
                }
                catch (Exception e) {
                    e.printStackTrace();
                }
            }
            else if (task == 5) {
                System.out.println("Getting Here in the Students Table Repopulate Method 2");
                // Get A List of the Students Associated With
                // the Currently Selected ClassType.
                ArrayList<Student> studentsInClassList = manager.getStudentsAssociatedWithClass(selectedClassType.getClassID());
                // Re-Initialize the All Students Table
                // ArrayList to Remove Any Previous Entries.
                allStudentsList = new ArrayList<>();
                // Retrieve A List of All The Student Accounts Present
                // Within the Remote Database.
                allStudentsList = manager.findAllStudents();
                
                // Check to see if Student is Already Present Within Class
                for (int i = 0; i < allStudentsList.size(); i++) {
                    // Iterate Through List of Students Already Present
                    // Within the Class.
                    for (int j = 0; j < studentsInClassList.size(); j++) {
                        // Check to See if the Current Student Identification Number
                        // Within the All Students List is the Same as the Student Identification Number
                        // Associated With the Current Student Object Entry in the Student's In Class List.
                        // If So, remove the Student Object From Both Lists. This is done to Stop the User
                        // from being able to Select A Student Already Present Within the Class.
                        if (allStudentsList.get(i).getStudentIdentificationNumber() == studentsInClassList.get(j).getStudentIdentificationNumber()) {
                            // Remove the Student Object From
                            // the All Students List.
                            allStudentsList.remove(i);
                            // Remove the Student Object From
                            // the Students in Class List.
                            studentsInClassList.remove(j);
                            // Seeing as We Are Removing
                            // the Entry, Go Back One Entry.
                            i--;
                            // Break From the Inner Loop
                            // Seeing as We Have Found A
                            // Student Present Within the Class
                            // who matches the Current All Students
                            // List Entry.
                            break;
                        }
                    }
                }
                
                // Reset the Row Data ArrayList Containing All of
                // our All Students Table Objects. This is done to
                // ensure that there are no other Entries Present
                // from a Previous Table View Process.
                rowDataListAllStudents = new ArrayList<>();
                
                // Loop Through Our Now, Non-Enrolled Student List
                // to Create A New ArrayList of CustomJTableObjectManageStudentsPanel
                // Objects. This List Will Be used to Populate the All Students
                // Table.
                for (int i = 0; i < allStudentsList.size(); i++) {
                    
                    // Get the Student's Small Profile Image FilePath String. This will be used in
                    // an ImageIcon conversion momentarily.
                    String image = "" + allStudentsList.get(i).getStudentProfileImageSmall();
                    // Retrieve the Student's Display Name which is a Combination of thier
                    // First and Last Names.
                    String name = "  " + allStudentsList.get(i).getStudentDisplayName() + "  ";
                    // Retrieve the Student's Associated Username for thier Account.
                    String username = "  " + allStudentsList.get(i).getStudentUsername() + "  ";
                    // Retrieve the Student's Email Address 
                    // associated with thier Account.
                    String email = "";
                    // Retrieve the Student's Phone Number 
                    // associated with thier Account.
                    String phone = "";
                    // Retrieve the Student's Physical Address 
                    // associated with thier Account.
                    String address = "";

                    // If the Student's Email Address Field is Empty, set the JTable Display
                    // Value to N/A (Not Available). This will also be serpated by two spaces on
                    // both sides in order to distance the width between column information in the
                    // Table. This is done to improve Application Aestheics and Table Readability.
                    if (allStudentsList.get(i).getStudentEmail().equalsIgnoreCase("")) {
                        // Assign the Not Available Value
                        // to the String.
                        email = "  N/A  ";
                    }
                    else {
                        // If the Email Address Field is not empty, assign the actual value
                        // once again seperated on both sides by two spaces.
                        email = "  " + allStudentsList.get(i).getStudentEmail() + "  ";
                    }

                    // If the Student's Phone Number Field is Empty, set the JTable Display
                    // Value to N/A (Not Available). This will also be serpated by two spaces on
                    // both sides in order to distance the width between column information in the
                    // Table. This is done to improve Application Aestheics and Table Readability.
                    if (allStudentsList.get(i).getStudentPhone().equalsIgnoreCase("") || allStudentsList.get(i).getStudentPhone().equalsIgnoreCase("Default")) {
                        // Assign the Not Available Value
                        // to the String.
                        phone = "  N/A  ";
                    }
                    else {
                        // If the Phone Number Field is not empty, assign the actual value
                        // once again seperated on both sides by two spaces.
                        phone = "  " + allStudentsList.get(i).getStudentPhone() + "  ";
                    }

                    // If the Student's Physical Address Field is Empty, set the JTable Display
                    // Value to No Address Available. This will also be serpated by two spaces on
                    // both sides in order to distance the width between column information in the
                    // Table. This is done to improve Application Aestheics and Table Readability.
                    if (allStudentsList.get(i).getStudentAddress().equalsIgnoreCase("")) {
                        // Assign the No Address Available Value
                        // to the String.
                        address = "  No Address Available  ";
                    }
                    else {
                        // If the Physical Address Field is not empty, assign the actual value
                        // once again seperated on both sides by two spaces.
                        address = "  " + allStudentsList.get(i).getStudentAddress() + "  ";
                    }

                    // Use the previously calculated Values to Form A New CustomJTableObjectManageStudentsPanel
                    // and add it to the rowDataListAllStudents ArrayList which will be used later to create
                    // All Students JTable Object.
                    rowDataListAllStudents.add(new CustomJTableObjectManageStudentsPanel(new javax.swing.ImageIcon(getClass().getResource(image)), name, allStudentsList.get(i).getStudentIdentificationNumber(), username, email, phone, address));
                }
                
                /***************************************************/

                // Execute if the All Students Class List Table
                // is Empty.
                if (rowDataListAllStudents.isEmpty()) {

                    // Create the New Table Model Using an Empty List
                    allStudentsModel = new CustomJTableModelManagementTabStudents(rowDataListAllStudents);
                    // Set the Table to show A Blank Model which will
                    // be automatically resized to fit the Container ScrollPane.
                    allStudentsTable.setModel(allStudentsModel);

                    // Disable Column Reordering so the User wont violate
                    // or change the Table's Settings.
                    allStudentsTable.getTableHeader().setReorderingAllowed(false);

                    // Show that the Default Table Model is not currently in use.
                    // This is done to Let the Program know when to show or hide
                    // components upon click.
                    defaultTableModelInUseAllStudentsList = false;

                    // In this next section of code, we will create multiple Custom Cell
                    // Renderer Objects. These Objects are responsible for changing the Overall
                    // Appearance of the Cells (Such as Background and Vertical / Horizontal Data Alignment)
                    // along with Changing things such as Data Font Type, Size, and Color. There are Two
                    // Different Types of Cell Renderers. One for the Header or "Title" Cells of A Column
                    // while the other is used to manipulate the contents of the Data Cells Contained
                    // Underneath.

                    // Create A Custom Cell Render which will be used on each of the
                    // Data Cell Rows within the Table. This Renderer will set the Font
                    // to the Regular "Lucida Grande" Font and Align the Contained text
                    // within the Center of the Cell.
                    DefaultTableCellRenderer renderer = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 0, 13));
                             // Return the Custom Cell Renderer Object
                             // which will be assigned to all Data Cells
                             // within the Table.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Black and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererBlack = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Black.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(0, 0, 0));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Royal Blue and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererRoyalBlue = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Royal Blue.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(51, 153, 255));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Set the Height of Each Row within the Table
                    // to 100 Pixels. This is done so that the Contained Data
                    // is more Seperated and thus easier to Read.
                    allStudentsTable.setRowHeight(100);

                    // Assign the Data Cell Renderer created earlier to Columns (1 - 6) Within
                    // the Table. Seeing as the First Column will contain the Student's Associated
                    // Profile Image, we will not assign a Cell Renderer to the Column. Should we
                    // Assign the cell Renderer to Column 0, a filepath to the Student's Profile Picture
                    // will be shown instead of the Actual Desired Image.

                    // Assign Data Cell Render to Column 1 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(1).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 2 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(2).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 3 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(3).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 4 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(4).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 5 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(5).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 6 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(6).setCellRenderer(renderer);

                    // Assign the Custom Cell Header Renderer Objects to each of the Columns Within
                    // the Table. We will Alternate in Assigning the Black and Royal Blue HeaderRenderer Objects
                    // by one cell each. This is done to make the Table more Aesthetically Pleasing in
                    // addition to helping with Overall Data Readability.

                    // Assign the Custom Black Header Render Object to Column 0 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(0).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 1 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(1).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 2 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(2).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 3 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(3).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 4 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(4).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 5 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(5).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 6 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(6).setHeaderRenderer(headerRendererBlack);

                    // Seeing as we are using an Empty ArrayList to Form this Table, the
                    // Width of all the Column Header Cells Combined won't be long enough to fill
                    // the entirety of the ScrollPane holding our JTable. Thus, we Assign the 
                    // AUTO_RESIZE_ALL_COLUMNS Integer to the JTable setAutoResizeMode() method.
                    // This will Automatically Resize All of the Columns withing the Table to
                    // Fill the Length of the ScrollPane. This is done for Aesthetic Improvement
                    // to the Program.
                    allStudentsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);

                    // Hide the Loading Icon in MainScreen Management Tab
                    // seeing as we have now retrieved the Student Data and
                    // used it to Create our Table.
                    main.jLabel62.setVisible(false);

                    // Hide the Table View Type Selection Components
                    // From the Users View.
                    setTableTypeSelectionComponentsVisible(false);
                    // Seeing as we now have our Table Completely made
                    // and the Loading Icon has been hidden. Renable the
                    // Table View Type Selection Components.
                    enableTableTypeSelectionComponents(true);

                    // Create an HTML Formatted Text String for the Title
                    // JLabel Located Above the Students in Class Table.
                    String formattedHtmlClassTitle = "<html><center><font color=#0093ff>" + selectedClassType.getClassTitle() + "</font> (<font color=#ff0000>All Students Not In Class</font>):</center></html>";
                    // Make the JLabel Show  the Title of the Currently
                    // Selected Class in a Royal Blue Color.
                    jLabel1.setText(formattedHtmlClassTitle);

                    // Show the All Student's Table and its Accompanying
                    // Components Seeing as the Table's Model has been Set
                    // and everything else has finished.
                    setAllStudentsListComponentsVisible(true);
                }
                // Execute if the All Students ArrayList
                // is not Empty.
                else {
                    // Once the Loop has finished Executing, Use the new rowDataListStudentsInClass ArrayList
                    // to create the Student's In Class Table Model.
                    allStudentsModel = new CustomJTableModelManagementTabStudents(rowDataListAllStudents);
                    // Set this new model to our classListTable JTable's
                    // custom model field.
                    allStudentsTable.setModel(allStudentsModel);

                    // Disable Table Column Reordering. This is done to prevent
                    // the user from Accidently altering or violating the Table's
                    // set Properties.
                    allStudentsTable.getTableHeader().setReorderingAllowed(false);

                    // Seeing as we are using a Custom Model for our Student's In
                    // Class JTable, we will set the Default Table Model Boolean
                    // Value to Zero. This is done to let Otther event Queue Threads
                    // know when to Show / Hide or Enable / Disable other Components.
                    defaultTableModelInUseAllStudentsList = false;

                    // In this next section of code, we will create multiple Custom Cell
                    // Renderer Objects. These Objects are responsible for changing the Overall
                    // Appearance of the Cells (Such as Background and Vertical / Horizontal Data Alignment)
                    // along with Changing things such as Data Font Type, Size, and Color. There are Two
                    // Different Types of Cell Renderers. One for the Header or "Title" Cells of A Column
                    // while the other is used to manipulate the contents of the Data Cells Contained
                    // Underneath.

                    // Create A Custom Cell Render which will be used on each of the
                    // Data Cell Rows within the Table. This Renderer will set the Font
                    // to the Regular "Lucida Grande" Font and Align the Contained text
                    // within the Center of the Cell.
                    DefaultTableCellRenderer renderer = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 0, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Data Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Black and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererBlack = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Black.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(0, 0, 0));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Create A Custom Column Header Renderer. This Will be used to both
                    // Center and Change the Accompanying Font / Background of the Chosen
                    // Column Title Cell. This Particular Renderer is responsible for Changing
                    // the Column Cells Background Color to Royal Blue and its Font Color to White.
                    // Additionally, it will set the Font to the Bold "Lucida Grande" Font and 
                    // Horizontally Center the Column Title Within the Cell.
                    DefaultTableCellRenderer headerRendererRoyalBlue = new DefaultTableCellRenderer(){
                        @Override
                        public Component getTableCellRendererComponent(JTable arg0,Object arg1, boolean arg2, boolean arg3, int arg4, int arg5) {
                             Component tableCellRendererComponent = super.getTableCellRendererComponent(arg0, arg1, arg2, arg3, arg4, arg5);
                             // Create Integer Variable that holds the Dimension Location
                             // of the Center of the Cell.
                             int align = DefaultTableCellRenderer.CENTER;
                             // Assign the Center Location to the Cells Data Positioning Method.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setHorizontalAlignment(align);
                             // Set the Background Color of the Cell to Royal Blue.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setBackground(new java.awt.Color(51, 153, 255));
                             // Set the Font Color of the Data Within the Cell to White
                             // in order to Contrast the Background.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setForeground(new java.awt.Color(255, 255, 255));
                             // Assign a Font to the Data Contained Within the Cell.
                             ((DefaultTableCellRenderer)tableCellRendererComponent).setFont(new java.awt.Font("Lucida Grande", 1, 13));
                             // Return the Custom Cell Renderer Object
                             // which Can be Assigned to a Header Column Cell.
                             return tableCellRendererComponent;
                        }
                    };

                    // Set the Height of Each Row within the Table
                    // to 100 Pixels. This is done so that the Contained Data
                    // is more Seperated and thus easier to Read.
                    allStudentsTable.setRowHeight(100);

                    // Assign the Data Cell Renderer created earlier to Columns (1 - 6) Within
                    // the Table. Seeing as the First Column will contain the Student's Associated
                    // Profile Image, we will not assign a Cell Renderer to the Column. Should we
                    // Assign the cell Renderer to Column 0, a filepath to the Student's Profile Picture
                    // will be shown instead of the Actual Desired Image.

                    // Assign Data Cell Render to Column 1 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(1).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 2 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(2).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 3 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(3).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 4 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(4).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 5 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(5).setCellRenderer(renderer);
                    // Assign Data Cell Render to Column 6 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(6).setCellRenderer(renderer);

                    // Assign the Custom Cell Header Renderer Objects to each of the Columns Within
                    // the Table. We will Alternate in Assigning the Black and Royal Blue HeaderRenderer Objects
                    // by one cell each. This is done to make the Table more Aesthetically Pleasing in
                    // addition to helping with Overall Data Readability.

                    // Assign the Custom Black Header Render Object to Column 0 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(0).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 1 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(1).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 2 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(2).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 3 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(3).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 4 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(4).setHeaderRenderer(headerRendererBlack);
                    // Assign the Custom Royal Blue Header Render Object to Column 5 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(5).setHeaderRenderer(headerRendererRoyalBlue);
                    // Assign the Custom Black Header Render Object to Column 6 Within the Table.
                    allStudentsTable.getColumnModel().getColumn(6).setHeaderRenderer(headerRendererBlack);

                    // Turn off Auto Resize Mode Within the Table. In the Next Step,
                    // we will Calculate the Desired Width of Each Column by mesauring
                    // the length of the longest piece of Data contained within all the
                    // rows present in the Table. We turn the Auto Resize Mode off so that
                    // the Data is all clearly show to the User.
                    allStudentsTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);

                    // Adjust Column Widths According to Largest Piece of Data Contained
                    // within one row in each column. Loop until all of the Columns have been
                    // searched through and set the Associated Width of the Longest Data Entry
                    // within thier ranks.
                    for (int column = 0; column < allStudentsTable.getColumnCount(); column++)
                    {
                        // Retrive the Table Column Model Object Associated with the Current
                        // Column Number that the loop is on.
                        TableColumn tableColumn = allStudentsTable.getColumnModel().getColumn(column);
                        // Retrieve the Prefered Width of the Column. This is the Actual Width
                        // Associated with the Column Object Within the Table.
                        int preferredWidth = tableColumn.getMinWidth();
                        // Retrieve the Max Width of the Column. This is the Width which the
                        // column may be stretched too should it be required.
                        int maxWidth = tableColumn.getMaxWidth();

                        // Loop through each of the Rows Within the Current Column
                        for (int row = 0; row < allStudentsTable.getRowCount(); row++)
                        {
                            // Retrieve the Cell Renderer Object Associated With the Current
                            // Column and Row Number. This will be used to retrieve the size
                            // information of the Data Contained within the Cell.
                            TableCellRenderer cellRenderer = allStudentsTable.getCellRenderer(row, column);
                            // Convert the Cell Renderer into a Generic Component Object to Retrieve
                            // the Data Size Information.
                            Component c = allStudentsTable.prepareRenderer(cellRenderer, row, column);
                            // Retrieve the Prefered Width of the Components Containing the Data.
                            // The Prefered Width is the current width of the Compononet after all of the
                            // changes we invoked earlier. We then combine this with the Intercell Spacing
                            // Width to get the Length in Pixels of the Data.
                            int width = c.getPreferredSize().width + allStudentsTable.getIntercellSpacing().width;
                            // Get the Maximum Size that the Cell's Width Can Become.
                            preferredWidth = Math.max(preferredWidth, width);

                            // Check to see if the Preferered Width is greater than the
                            // Cells Maximum Visible Dimension Size. If so,
                            // We've exceeded the maximum width, so theres
                            // no need to check other rows.
                            if (preferredWidth >= maxWidth)
                            {
                                // Set the Prefered Width to the Max
                                // Width's Size.
                                preferredWidth = maxWidth;
                                // Break Inner Loop.
                                break;
                            }
                        }

                        // Set the Prefererd Width of the Current Column to
                        // the Maximum Width Required to Fully Display the
                        // longest piece of information.
                        tableColumn.setPreferredWidth(preferredWidth);
                    }

                    // Seeing as We have made changes to the Original Structure
                    // of the JScrollPane Viewport, revalidate the object before repainting
                    // it to the Screen.
                    allStudentsTableScrollPane.revalidate();
                    allStudentsTableScrollPane.repaint();

                    // Seeing as We have made changes to the Original Structure
                    // of the JTable, revalidate the object before repainting
                    // it to the Screen.
                    allStudentsTable.revalidate();
                    allStudentsTable.repaint();

                    // Create Integer Array Variable to Hold the Individual Width's
                    // of each Column now that the resizing operations have been
                    // performed.
                    int[] columnWidths = {0, 0, 0, 0, 0, 0, 0};

                    // Get the Current Width of the First Column.
                    columnWidths[0] = allStudentsTable.getColumnModel().getColumn(0).getPreferredWidth();
                    // Get the Current Width of the Second Column.
                    columnWidths[1] = allStudentsTable.getColumnModel().getColumn(1).getPreferredWidth();
                    // Get the Current Width of the Third Column.
                    columnWidths[2] = allStudentsTable.getColumnModel().getColumn(2).getPreferredWidth();
                    // Get the Current Width of the Forth Column.
                    columnWidths[3] = allStudentsTable.getColumnModel().getColumn(3).getPreferredWidth();
                    // Get the Current Width of the Fifth Column.
                    columnWidths[4] = allStudentsTable.getColumnModel().getColumn(4).getPreferredWidth();
                    // Get the Current Width of the Sixth Column.
                    columnWidths[5] = allStudentsTable.getColumnModel().getColumn(5).getPreferredWidth();
                    // Get the Current Width of the Seventh Column.
                    columnWidths[6] = allStudentsTable.getColumnModel().getColumn(6).getPreferredWidth();

                    // Combine All of the Column Widths to get A Total
                    // Width in pixels. This is done to provide a comparison
                    // value in the next step.
                    int jTableWidth = columnWidths[0] + columnWidths[1] + columnWidths[2] + columnWidths[3] + columnWidths[4] + columnWidths[5] + columnWidths[6];

                    // If The Width of All the Current Columns in the JTable is
                    // Less than the Size of the JScrollPane's Visible Viewport Width, then
                    // resize the Last Column to Fit the Entire ScrollPane Width
                    if (jTableWidth < 754) {
                        // Set JTable Resize Mode to Automatically Resize the Last Column
                        // should the current assortment of the Datat contained within all of
                        // the columns and rows is less in pixel width than the visible
                        // Area of the Container JViewPort.
                        allStudentsTable.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
                    }

                    // Hide the Loading Icon in MainScreen Management Tab
                    // seeing as we have now retrieved the Student Data and
                    // used it to Create our Table.
                    main.jLabel62.setVisible(false);
                }
            }
            // Create A Thread that Waits for the User to choose
            // an option in the Add Student Confirmaiton Window. This
            // process occurs while the user is manipulating the All Students
            // Table.
            else if (task == 6) {
                
                while (true) {
                    // Yes Option Clicked
                    if (messageResponseTracker.getAddStudentResponseAllStudentsSegmentValue() == 1) {
                        
                        DatabaseOperationResult result = manager.createStudentClassLinkStudentsInClass(selectedStudentAllStudents.getStudentIdentificationNumber(), tracker.getCurrentInstructorInformation().getInstructorID(), classType.getClassID());
                        //StatusMessageStudentSuccessfullyAdded
                        
                        if (result.getResult() == false) {
                            
                        }
                        else {
                            StatusMessageStudentModificationSuccessful smssa = new StatusMessageStudentModificationSuccessful(2);
                            String formattedHTML = "<html><center>Student <font color=#00fddb>" + selectedStudentAllStudents.getStudentDisplayName() + "</font> has successfully been added to Class <font color=#00ec3c>" + classType.getClassTitle() + "</font>.</center></html>";
                            
                            smssa.jLabel6.setText(formattedHTML);
                            smssa.setVisible(true);
                        }
                        
                        break;
                    }
                    // No Option Clicked
                    else if (messageResponseTracker.getAddStudentResponseAllStudentsSegmentValue() == 2) {
                        
                        enableAllStudentsTableComponents(true);
                        
                        break;
                    }
                    // Cancel Option Clicked
                    else if (messageResponseTracker.getAddStudentResponseAllStudentsSegmentValue() == 3) {
                        
                        enableAllStudentsTableComponents(true);
                        
                        break;
                    }
                }
            }
            
            return null;
        }
        
        // This method is automatically invoked after the
        // doInBackground() method has finished
        // executing.
        @Override
        protected void done() {
            // Make the GuiFour Frame
            // invisible.
            //setVisible(false);
            //dispose();
        }
    }
}
